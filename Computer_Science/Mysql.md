



# Mysql

## 数据库概述

### 背景：

- 持久化(persistence)： 把数据保存到可掉电式存储设备中以供之后使用 。大多数情况下，特别是企 业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以”固化” ，而持久化的实现过程大多 通过各种关系数据库来完成。
- 持久化的主要作用是 将内存中的数据存储在关系型数据库中 ，当然也可以存储在磁盘文件、XML数 据文件中。

### 概念

- DB：数据库（Database）
  - 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。
- DBMS：数据库管理系统（Database Management System）
  - 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控 制。用户通过数据库管理系统访问数据库中表内的数据。
- SQL：结构化查询语言（Structured Query Language）
  - 专门用来与数据库通信的语言。
- 数据库与数据库管理系统的关系
  - 数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存 应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。

### RDBMS 与 非RDBMS

- 关系型数据库(RDBMS)

  - 这种类型的数据库是  最古老  的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系  （即二维表格形式）。
  - 关系型数据库以  行(row)  和  列(column)  的形式存储数据，以便于用户理解。这一系列的行和列被 称为  表(table)  ，一组表组成了一个库(database)。
  - 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型  来表示。关系型数据库，就是建立在  关系模型  基础上的数据库。
  - SQL 就是关系型数据库的查询语言。

- 非关系型数据库(非RDBMS)

  - 相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和 列存储等，除此以外还包括图形数据库。也只有用  NoSQL 一词才能将这些技术囊括进来。

  - 键值型数据库
  - 文档型数据库
  - 搜索引擎数据库
  - 列式数据库
  - 图形数据库

### 关系型数据库设计规则

- 关系型数据库的典型数据结构就是  数据表  ，这些数据表的组成都是结构化的（Structured）。 
- 将数据放到表中，表再放到库中。
- 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 
- 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。

##### 表、记录、字段

- E-R（entity-relationship，实体-联系）模型中有三个主要概念是：  实体集  、  属性  、  联系集  。
- 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表 中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。

##### 表的关联关系

- 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型来表示。
- 四种：一对一关联、一对多关联、多对多关联、自我引用

###### 一对一

- 在实际的开发中应用不多，因为一对一可以创建成一张表。
- 两种建表原则：
  - 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 
  - 外键是主键：主表的主键和从表的主键，形成主外键关系。

######  一对多

- 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键

###### 多对多

- 要表示多对多关系，必须创建第三个表，该表通常称为  联接表  ，它将多对多关系划分为两个一对多关 系。将这两个表的主键都插入到第三个表中。

###### 自我引用(Self reference)

## SQL

### 分类

- DDL（Data Definition Languages、数据定义语言） ，这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。
  - 主要的语句关键字包括  CREATE  、  DROP  、  ALTER  等。
- DML（Data Manipulation Language、数据操作语言） ，用于添加、删除、更新和查询数据库记 录，并检查数据完整性。
  - 主要的语句关键字包括  INSERT  、  DELETE  、  UPDATE  、  SELECT  等。 
  - SELECT是SQL语言的基础，最为重要。
- DCL（Data Control Language、数据控制语言） ，用于定义数据库、表、字段、用户的访问权限和 安全级别。
  - 主要的语句关键字包括  GRANT  、  REVOKE  、  COMMIT  、  ROLLBACK  、  SAVEPOINT  等。

- 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（Data Query Language）。
  还有单独将  COMMIT  、  ROLLBACK    取出来称为TCL （Transaction Control Language，事务控制语 言）。

### 规则与规范

#### 基本规则

- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 
- 每条命令以 ; 或 \g 或 \G 结束
  关键字不能被缩写也不能分行 
- 关于标点符号
  - 必须保证所有的()、单引号、双引号是成对结束的 
  - 必须使用英文状态下的半角输入方式
  - 字符串型和日期时间类型的数据可以使用单引号（' '）表示 
  - 列的别名，尽量使用双引号（" "），而且不建议省略as

#### 大小写规范

- 数据库名、表名、表别名、字段名、字段别名等都小写 
- SQL 关键字、函数名、绑定变量等都大写

#### 注 释

- 单行注释：#注释文字(MySQL特有的方式)
- 单行注释：-- 注释文字(--后面必须包含一个空格。) 
- 多行注释：/* 注释文字         */

#### 命名规则

- 数据库、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符
- 数据库名、表名、字段名等对象名中间不要包含空格
  同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；
- 同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来
- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了

#### 数据导入指令

- 使用source指令导入

## DML的DQL

### 主体

1. SELECT...

   - ```sql
     SELECT 1; #没有任何子句 
     SELECT 9/2; #没有任何子句
     ```

2. SELECT   标识选择哪些列 FROM     标识从哪个表中选择

3. 选择全部列：SELECT * FROM   departments;

   - 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。
   - 在生产环境下，不推荐你直接使用  SELECT * 进行查询。

4. 选择特定的列：SELECT department_id, location_id FROM   departments;

   - MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人 员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代 码更容易阅读和维护。

5. 列的别名

   1. 重命名一个列 
   2. 便于计算
   3. 紧跟列名，也可以 在列名和别名之间加入关键字AS，别名使用双引号 ，以便在别名中包含空格或特 殊的字符并区分大小写。
   4. AS 可以省略
   5. 建议别名简短，见名知意

6. 去除重复行

   1. 在SELECT语句中使用关键字DISTINCT去除重复行
   2. SELECT DISTINCT department_id FROM   employees;
   3. DISTINCT 需要放到所有列名的前面，如果写成  SELECT salary, DISTINCT department_id FROM employees 会报错。
   4. DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部 门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需 要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。

7. 空值参与运算

   1. 所有运算符或列值遇到null值，运算的结果都为null
   2. 解决方案使用IFNULL（num1，num2）如果num1不为null则使用num1，num1为null则使用num2
   3. 这里你一定要注意，在 MySQL 里面，  空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的。

8. 着重号

   1. 错误的:SELECT * FROM ORDER;
   2. 正确的：SELECT * FROM `ORDER`;
   3. 我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对``（着重号）引起来。

9. 查询常数

   1. SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的 取值是我们指定的，而不是从数据表中动态取出的。
   2. SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个 固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。
   3. 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段  corporation ，这个 字段固定值为“corporation1”
      1. SELECT 'corporation1' as corporation, last_name FROM employees; 

10. 显示表结构

    1. 使用DESCRIBE 或 DESC 命令，表示表结构。
       1. DESCRIBE employees; 或DESC employees;
          1. Field：表示字段名称。
          2. Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 
          3. Null：表示该列是否可以存储NULL值。
          4. Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；
          5. UNI表示该列是UNIQUE索引的一 部分；
          6. MUL表示在列中某个给定值允许出现多次。
          7. Default：表示该列是否有默认值，如果有，那么值是多少。
          8. Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。

11. 过滤数据

    1. SELECT 字段1,字段2 FROM 表名 WHERE 过滤条件

    2. 使用WHERE 子句，将不满足条件的行过滤掉 WHERE子句紧随 FROM子句

       1. ```sql
          SELECT employee_id, last_name, job_id, department_id 
          FROM   employees
          WHERE department_id = 90 ;
          ```

### 算术运算符

| 运算符 | 名称              | 作用                     | 示例                      |
| ------ | ----------------- | ------------------------ | ------------------------- |
| +      | 加法运算符        | 计算两个值或表达式的和   | SELECTA＋B                |
| -      | 减法运算符        | 计算两个值或表达式的差   | SELECT A- B               |
| *      | 乘法运算符        | 计算两个值或表达式的乘积 | SELECT A*B                |
| /或DIV | 除法运算符        | 计算两个值或表达式的商   | SELECT A/B或SELECTA DIV B |
| %或MOD | 求模(求余）运算符 | 计算两个值或表达式的余数 | SELECT A MOD B            |

#### 加法与减法运算符

- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；
- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数 值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）

#### 乘法与除法运算符

- 一个数乘以整数1和除以整数1后仍得原数；
- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；
- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；
- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位； 
- 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。

求模（取余）运算符

### 比较运算符

| 运算符 | 名称           | 作用                                                         | 示例                            |
| ------ | -------------- | ------------------------------------------------------------ | ------------------------------- |
| =      | 等于运算符     | 判断两个值、字符串或表达式是否相等                           | SELECT C FROM TABLE WHERE A =B  |
| <=>    | 安全等于运算符 | 安全地判断两个值、字符串或表达式是否相等                     | SELECT C FROM TABLE WHEREA<=> B |
| <>(!=) | 不等于运算符   | 判断两个值、字符串或表达式是否不相等                         | SELECT C FROM TABLE WHEREA<> B  |
| <      | 小于运算符     | 判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA< B   |
| <=     | 小于等于运算符 | 判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA<=B   |
| >      | 大于运算符     | 判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA> B   |
| >=     | 大于等于运算符 | 判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA> =B  |

#### 等号运算符（=）

- 判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回 0。
- 在使用等号运算符时，遵循如下规则：
  - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等。
  - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。
  - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
  - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。
- 对比：SQL中赋值符号使用  :=

#### 安全等于运算符 

安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 是‘<=>’可 以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL 时，其返回值为0，而不为NULL。

#### 不等于运算符

#### 非符号类型运算符

| 运算符                        | 名称             | 作用                                   | 示例                                                         |
| ----------------------------- | ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| IS NULL                       | 为空运算符       | 判断值或表达式是否为空                 | SELECT 1 IS NULL,NULL IS NULL;                               |
| IS NOT NULL                   | 不为空运算符     | 判断值或表达式是否不为空               | SELECT I IS NOT NULL,NULL IS NOT NULL;                       |
| LEAST                         | 最小运算符       | 在多个值里面返回最小值                 | SELECT LEAST(‘A’,‘G’,‘P’);                                   |
| BETWEEN 数字下限 AND 数字上限 | 两者之间运算符   | 在下限和上限之间取值                   | SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000; |
| IN                            | 属于运算符       | 判断值或者表达式是否是列表中的一个值   | SELECT 1 IN(1,2,3);                                          |
| NOT IN                        | 不属于运算符     | 判断表达式或者值是否不是列表中的一个值 | SELECT 2 NOT IN(1,2,3);                                      |
| LIKE                          | 模糊匹配运算符   | 判断一个值是否符合模糊匹配规则         | SELECT * FROM employees WHERE last_name LIKE ‘%a%’;          |
| REGEXP                        | 正则表达式运算符 | 判断一个值是否符合正则表达式规则       | SELECT ‘xykstart’ REGEXP ‘^x’,‘xykstart’ REGEXP ‘$t’,‘xykstart’ REGEXP ‘st’, |
| RLIKE                         | 正则表达式运算符 | 判断一个值是否符合正则表达式规则       | SELECT ‘zzzz’ RLIKE ‘^z’;                                    |

##### 1、空运算符

- 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0

##### 2、非空运算符

- 非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。

3、小值大值运算符

- 语法格式为：LEAST(值1，值2，…，值n)。

- 其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回 小值。
- 语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。
- 当有两个或多个参数时，返回值为 大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。

4、BETWEEN AND 运算符

- BETWEEN运算符使用的格式通常为 `SELECT D FROM TABLE WHERE C BETWEEN A AND B` ，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。
- 在使用 BETWEEN AND 运算符时，结果集中包含查询边界。

##### 5、IN 运算符

- IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。

##### 6、NOT IN 运算符

- NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。有 NULL 参与结果就是 NULL

##### 7、LIKE 模糊运算符

- LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。
- LIKE 运算符使用以下通配符：
- % ->：匹配任意多个字符（0-n）
- _ ->：当一个占位符的使

###### ESCAPE 关键字

- 如果在使用转义符时不想使用 \ 下划线做转义符，就能使用 ESCAPE 关键字声明一个符号为转义符。
- 使用 \ 下划线就可以省略这个步骤。

##### 8、REGEXP 运算符

- 正则表达式（英语：Regular Expression，常简写为regex、regexp或RE）。
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串

- 基本字符匹配

  - 检索列 column包含文本text的所有行：where column regexp ‘text’

  - . :点. 是正则表示式中一个特殊的字符。它表示匹配任意一个字符，相当于通配符_


- 区分大小写

  - mysql默认不区分大小写，提供使用Binary关键字区分 Regexp Binary ‘ Text ’

- 进行or匹配

  - 搜索多个字符串之一，使用 | ，Regexp ‘text1 | text2’

- 匹配几个字符之一

  - []：[]是另一种形式的or语句，是|的缩写
  - ' [123]num '='[1|2|3]num '='1num|2num|3num'

- 匹配范围

  - [0-9] ,[a-z],[1-3]

- 匹配特殊字符

  - 匹配具有特殊含义的字符 
    - 查找- ：\\-
    - 匹配\ ：\\\
    - 空白元字符
      - \f：换页
      - \n：换行
      - \r：回车
      - \t：制表
      - \v: 纵向制表
      - 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身，但是MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。

- 匹配多个实例

  - 重复元字符：
  - *：0个或多个匹配
  - +：1个或多个 匹配（相当于{1，}）
  - ？：0个或一个匹配（相当于{0,1}）
  - {n}：指定数目的匹配
  - {n，}：不少于指定数目的匹配
  - {n，m}：匹配数目的范围（m不超过255）
    - 匹配连在一起的四位数字： '[[:digit:]]{4}'

- 定位符

  ```mysql
  定位元字符：
  ^:文本的开始
  $:文本的结束
  [[:<:]]:词的开始
  [[:>:]]:词的末尾
  ```

  - ^ 符号的双重用途： ^在集合中（用 [ ] 定义）时用它来否定该集合，否则用来指定串的开始处。
  - 词的匹配分别匹配一个单词开头和结尾的空的字符串，这个单词开头和结尾都不是包含在alnum中的字符也不能是下划线。(alnum表示英文字母和数字字符)

- 匹配字符类

  ```mysql
  [:alpha:]	：匹配当前归类中的大写和小写字母字符。例如，'[0-9]{3}[[:alpha:]]{2}' 匹配三个数字，后跟两个字母。
  
  [:alnum:]	：匹配当前归类中的数字、大写和小写字母字符。例如，'[[:alnum:]]+' 匹配含有一个或多个字母和数字的字符串。
  
  [:digit:]	：匹配当前归类中的数字。例如，'[[:digit:]-]+' 匹配含有一个或多个数字或横线的字符串。同样，'[^[:digit:]-]+' 匹配含有一个或多个不是数字或横线的字符的字符串。
  
  [:lower:]	：匹配当前归类中的小写字母字符。例如，'[[:lower:]]' 不匹配 A，因为 A 为大写。
  
  [:space:]	：匹配单个空格 (' ')。例如，搜索 Contacts.City 以查找任何名称为两个词的城市：
  [:upper:]	：匹配当前归类中的大写字母字符。例如，'[[:upper:]ab]' 与以下其中一项匹配：任何大写字母、a 或 b。
  
  [:whitespace:]	：匹配一个空白字符，例如，空格、制表符、换页符和回车符。
  
  [:ascii:]	：匹配任何七位的 ASCII 字符（0 到 127 之间的顺序值）。
  
  [:blank:]	：匹配一个空白区或水平制表符。
  
  [:blank:] 等效于 [ \t]。
  
  [:cntrl:]	：匹配顺序值小于 32 或字符值为 127 的 ASCII 字符（控制字符）。控制字符包括换行符、换页符、退格符，等等。
  
  [:graph:]	：匹配打印字符。
  
  [:graph:]  ：等效于 [[:alnum:][:punct:]]。
  
  [:print:]	：匹配打印字符和空格。
  
  [:print:] ：等效于 [[:graph:][:whitespace:]]。
  
  [:punct:]	：匹配其中一个字符： !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~.
  
  [:punct:] 子字符类不能包括当前归类中可用的非 ASCII 标点字符。
  
  [:word:]	：匹配当前归类中的字母、数字或下划线字符。
  
  [:word:] 等效于 [[:alnum:]_]。
  
  [:xdigit:]	：匹配字符类 [0-9A-Fa-f] 中的字符。
  ```

### 逻辑运算符

| 运算符      | 作用     |
| ----------- | -------- |
| NOT 或者 !  | 逻辑非   |
| AND 或者 && | 逻辑与   |
| OR 和 \|\|  | 逻辑或   |
| XOR         | 逻辑异或 |

- 逻辑非运算符  逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0； 当给定的值为NULL时，返回NULL。
- 逻辑与运算符  逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回 1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。
- 逻辑或运算符  逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返 回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为 NULL时，返回NULL。
  - OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先 对AND两边的操作数进行操作，再与OR中的操作数结合。
- 逻辑异或运算符  逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果 两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。

### 位运算符

| 运算符 | 说明   | 使用形式 | 举例                             |
| ------ | ------ | -------- | -------------------------------- |
| \|     | 位或   | a \| b   | 5 \| 8                           |
| &      | 位与   | a & b    | 5 & 8                            |
| ^      | 位异或 | a ^ b    | 5 ^ 8                            |
| ~      | 位取反 | ~a       | ~5                               |
| <<     | 位左移 | a << b   | 5 << 2，表示整数 5 按位左移 2 位 |
| >>     | 位右移 | a >> b   | 5 >> 2，表示整数 5 按位右移 2 位 |

- 按位与运算符  按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。

- 按位或运算符  按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的 二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。

- 按位异或运算符  按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值 对应的二进制位的数值不同时，则该位返回1，否则返回0。

- 按位取反运算符  按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。

  - ```mysql
    mysql> SELECT 10 & ~1;
    +---------+
    | 10 & ~1 |
    +---------+ 
    |      10 | 
    +---------+
    1 row in set (0.00 sec)
    ```

    

  - 由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进 行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。

- 按位右移运算符  按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。

- 按位左移运算符  按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。

###  运算符的优先级

| 优先级由低到高排列 | 运算符                                                       |
| ------------------ | ------------------------------------------------------------ |
| 1                  | =(赋值运算）、:=                                             |
| 2                  | II、OR                                                       |
| 3                  | XOR                                                          |
| 4                  | &&、AND                                                      |
| 5                  | NOT                                                          |
| 6                  | BETWEEN、CASE、WHEN、THEN、ELSE                              |
| 7                  | =(比较运算）、<=>、>=、>、<=、<、<>、!=、 IS、LIKE、REGEXP、IN |
| 8                  | \|                                                           |
| 9                  | &                                                            |
| 10                 | <<、>>                                                       |
| 11                 | -(减号）、+                                                  |
| 12                 | *、/、%                                                      |
| 13                 | ^                                                            |
| 14                 | -(负号）、〜（位反转）                                       |
| 15                 | !                                                            |

### 排序数据

- 使用 ORDER BY 子句排序
  - ASC（ascend）: 升序 DESC（descend）:降序
  - ORDER BY 子句在SELECT语句的结尾。
  - 列的别名只能在where子句之后使用
- 单列排序
  - ORDER BY 列1;
- 多列排序
  - ORDER BY 列1，列2;

### 分页

- 分页原理
  - 所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。
  - MySQL中使用 LIMIT 实现分页
- 格式：LIMIT [位置偏移量,] 行数
  - 第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移 量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）；第二个参数“行数”指示返回的记录条数。
  - MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。
  - 注意：LIMIT 子句必须放在整个SELECT语句的最后！
  - 约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。

### 多表查询

- 笛卡尔积（或交叉连接）的理解

  - 笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能 组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素 个数的乘积数。
  - 笛卡尔积的错误会在下面条件下产生 ：
    - 省略多个表的连接条件（或关联条件） 连接条件（或关联条件）无效
    - 所有表中的所有行互相连接
    - 为了避免笛卡尔积， 可以 在 WHERE 加入有效的连接条件。

- 等值连接

  - 多个表中有相同列时，必须在列名之前加上表名前缀。 在不同表中具有相同列名的列可以用 表名 加以区分。
  - 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替， 不能使用原有的表名，否则就会报错。
  - 【  强制  】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。
  - 说明  ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表 名），并且操作列在多个表中存在时，就会抛异常。
  - 正例  ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
  - 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年 后，最近在 某个表中增加一个同名字段，在预发布环境数据库变更后，线上查询语句出现出 1052 异常：Column 'name' in field list is ambiguous。
  - 连接  n个表,至少需要n-1个连接条件

- 自连接

  - 当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两 个表再进行内连接，外连接等查询。

- 外连接

  - 除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。

  - 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 

  - 外连接: 两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行   ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。 

  - 如果是左外连接，则连接条件中左边的表也称为  主表  ，右边的表称为  从表  。
    如果是右外连接，则连接条件中右边的表也称为  主表  ，左边的表称为  从表  。

  - 左外连接(LEFT OUTER JOIN)

    - ```mysql
      #实现查询结果是A
      SELECT 字段列表
      FROM A表    LEFT JOIN B表 ON 关联条件
      WHERE 等其他子句;
      ```

  - 右外连接(RIGHT OUTER JOIN)

    - ```mysql
      #实现查询结果是B
      SELECT 字段列表
      FROM A表    RIGHT JOIN B表 ON 关联条件
      WHERE 等其他子句;
      ```

  - 满外连接(FULL OUTER JOIN)

    - 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。
    - 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION  RIGHT join代替。

### 内置函数

#### 单行函数

- 操作数据对象
- 接受参数返回一个结果
- 只对一行进行变换 每行返回一个结果
- 可以嵌套
- 参数可以是一列或一个值

##### 数值函数

| 函数          | 功能                             |
| ------------- | -------------------------------- |
| ABS（x）      | 返回x的绝对值                    |
| CEIL（x）     | 返回大于x的最小整数值            |
| FLOOR(x)      | 返回小于x的最大整数值            |
| MOD（x/y）    | 返回x/y的模                      |
| RAND()        | 返回0-1的随机数                  |
| ROUND(x,y)    | 返回参数x的四舍五入的y位小数的值 |
| TRUNCATE(x,y) | 返回数字x截断为y位小数的结果     |

##### 时间函数

| 函数                              | 功能                                         |
| --------------------------------- | -------------------------------------------- |
| CURDATE()                         | 返回当前日期                                 |
| CURTIME()                         | 返回当前时间                                 |
| NOW()                             | 返回当前的时间                               |
| UNIX_TIMESTAMP(date)              | 返回日期date的UNIX时间戳                     |
| FROM_UNIXTIME                     | 返回UNIX时间戳的日期值                       |
| WEEK(date)                        | 返回日期date为一年中的第几周                 |
| YEAR（date）                      | 返回日期date的年份                           |
| HOUR(time)                        | 返回time的小时值                             |
| MINUTE(time)                      | 返回time的分钟值                             |
| MONTHNAME(date)                   | 返回date的月份名                             |
| DATE_FORMAT(date,fmt)             | 返回字符串fmt格式化日期date值                |
| DATE_ADD(date,INTERVAL expr type) | 返回一个日期或时间值加上一个时间间隔的时间值 |
| DATEDIFF(expr,expr2)              | 返回起始时间expr和结束时间expr2之间的天数    |

##### 字符串函数

| 函数          | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| Left（）      | 返回串左边的字符                                             |
| length（）    | 返回串的长度                                                 |
| locate（）    | 找出串的一个子串                                             |
| lower（）     | 将串转换为小写                                               |
| Upper（）     | 将串转换为大写                                               |
| LTrim（）     | 去除串左边的空格                                             |
| Right（）     | 返回串的右边的字符                                           |
| Rtrim（）     | 去掉右边的空格                                               |
| Soundex（）   | 返回串的Soundex值，Soundex是一个将任何文本串转换为描述器语音表示的字母数字模式的算法 |
| SubString（） | 返回子串的字符                                               |
| Upper（）     | 将串转换为大写                                               |

##### 流程控制函数

| 函数                                                         | 功能                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1， 否则返回value2 |
| IFNULL(value1, value2)                                       | 如果value1不为NULL，返回value1，否 则返回value2  |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END | 相当于Java的if...else if...else...               |
| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case...                     |

##### 加密与解密函数

| 函数                        | 功能                                                         |
| --------------------------- | ------------------------------------------------------------ |
| PASSWORD(str)               | 返回字符串str的加密版本，41位长的字符串。加密结果  不可 逆  ，常用于用户的密码加密 |
| MD5(str)                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL |
| SHA(str)                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。  SHA加密算法比MD5更加安全  。 |
| ENCODE(value,password_seed) | 返回使用password_seed作为加密密码加密value                   |
| DECODE(value,password_seed) | 返回使用password_seed作为加密密码解密value                   |

##### MySQL信息函数

| 函数                                                   | 功能                                                   |
| ------------------------------------------------------ | ------------------------------------------------------ |
| VERSION()                                              | 返回当前MySQL的版本号                                  |
| CONNECTION_ID()                                        | 返回当前MySQL服务器的连接数                            |
| DATABASE()，SCHEMA()                                   | DATABASE()，SCHEMA()                                   |
| USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() | USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() |
| CHARSET(value)                                         | 返回字符串value自变量的字符集                          |
| COLLATION(value)                                       | 返回字符串value的比较规则                              |

##### 其他函数

| 函数                           | 功能                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| FORMAT(value,n)                | 返回对数字value进行格式化后的结果数据。n表示  四舍五入  后保留 到小数点后n位 |
| CONV(value,from,to)            | CONV(value,from,to)                                          |
| INET_ATON(ipvalue)             | 将以点分隔的IP地址转化为一个数字                             |
| INET_NTOA(value)               | 将数字形式的IP地址转化为以点分隔的IP地址                     |
| BENCHMARK(n,expr)              | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 |
| CONVERT(value USING char_code) | 将value所使用的字符编码修改为char_code                       |

#### 多行函数（聚集）

- 聚合函数作用于一组数据，并对一组数据返回一个值。
- 聚集函数(aggregate function)
- 利用算术操作符可以用来执行多个列上的计算
- 只包含不同的值，指定Distinct参数
  - All为默认参数
  - Distinct不能用于Count（*）
- 运行在行组上，计算和返回单个值的函数
  - AVG（）
    - 返回某列的平均值
    - Avg（）只能确定特定数值列的平均值，而且列名必须作为函数参数给出。多个列的值需使用多个Avg（）函数
    - Avg（）函数忽略列值为null的行
  - Count（）
    - 返回某列的行数
    - 如果参数指定列名，null值被忽略。如果参数为*不忽略null值，对表中行的数目进行计数
  - Max（）
    - 返回某列的最大值
    - 忽略null值
    - 文本数据，如果数据按相应的列排序，返回最后面的行
  - Min（）
    - 返回某列的最小值
    - 文本数据，如果数据按相应的列排序，返回最前面的行
    - 忽略null值
  - Sum
    - 返回某列值之和
    - 忽略null值

##### Count

- 用count(*)，count(1)，count(列名)谁好呢?
  - 其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。
  - Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。
- 能不能使用count(列名)替换count(*)?*
- *不要使用 count(列名)来替代    count(*) ，  count(*) 是  SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。*
- 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为  NULL 值的行。

##### GROUP BY

- 可以使用GROUP BY子句将表中的数据分成若干组

```mysql
SELECT column, group_function(column) 
FROM table
[WHERE condition]
[GROUP BY  group_by_expression] 
[ORDER BY  column];
```

- WHERE一定放在FROM后面

- 在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中

  - 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中

- 多个列分组

  - ```mysql
    SELECT   department_id dept_id, job_id, SUM(salary) 
    FROM     employees
    GROUP BY department_id, job_id ;
    ```

- GROUP BY中使用WITH ROLLUP

  - 使用  WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所 有记录的总和，即统计记录数量。

##### HAVING

- 过滤分组：HAVING子句

  - 行已经被分组。

  - 使用了聚合函数。

  - 满足HAVING 子句中条件的分组将被显示。

  - HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。

- WHERE和HAVING的对比

  - 区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。

    - 这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。

  - 区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。

    -  这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。

  - |        | 优点                         | 缺点                                   |
    | ------ | ---------------------------- | -------------------------------------- |
    | WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |
    | HAVING | 可以使用分组中的计算函数     | 在最后的结果集中进行筛选，执行效率较低 |



#####  执行过程

- 方式1：
  - SELECT ...,....,... 
  - FROM ...,...,.... 
  - WHERE 多表的连接条件 AND 不包含组函数的过滤条件 
  - GROUP BY ...,... 
  - HAVING 包含组函数的过滤条件 
  - ORDER BY ... ASC/DESC 
  - LIMIT ...,...
- 方式2：
  - SELECT ...,....,... 
  - FROM ... JOIN ... ON 多表的连接条件
  - JOIN ... ON ...
    WHERE 不包含组函数的过滤条件 AND/OR 不包含组函数的过滤条件
  - GROUP BY ...,...
    HAVING 包含组函数的过滤条件 
  - ORDER BY ... ASC/DESC 
  - LIMIT ...,...

- 顺序：

  - （1）from：从哪些表中筛选

  - （2）on：关联多表查询时，去除笛卡尔积

  - （3）where：从表中筛选的条件

  - （4）group by：分组依据

  - （5）having：在统计结果中再次筛选

  - （6）order by：排序

  - （7）limit：分页

- SELECT执行顺序

  - 关键字的顺序是不能颠倒的：
    - SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
  - SELECT 语句的执行顺序 （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：
    - FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段    -> DISTINCT -> ORDER BY -> LIMIT

- 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个  虚拟表  ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在  SQL 的执行过程中，对于我们来说是不可见的。

- SQL 的执行原理

  - SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
    1.   首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
    2.   通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
    3.   添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。
  - 当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。
  - 我们拿到了查询数据表的原始数据，也就是最终的虚拟表    vt1 ，就可以在此基础上再进行    WHERE 阶 段  。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表    vt2 。
  - 然后进入第三步和第四步，也就是    GROUP 和     HAVING 阶段  。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表    vt3 和    vt4 。
  - 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到    SELECT 和     DISTINCT 阶段  。
  - 首先在 SELECT 阶段会提取想要的字段，然后在  DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和    vt5-2 。
  - 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是    ORDER BY 阶段  ，得到 虚拟表    vt6 。
  - 最后在 vt6 的基础上，取出指定行的记录，也就是    LIMIT 阶段  ，得到最终的结果，对应的是虚拟表 vt7 。
  - 当然我们在写  SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。
  - 同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序， 所谓底层运行的原理，就是我们刚才讲到的执行顺序。



### 子查询

- 子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。
- SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者 需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集 合）进行比较。
- 子查询（内查询）在主查询之前一次执行完成。 
- 子查询的结果被主查询（外查询）使用 。
- 分类
  - 按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。
  - 按内查询是否被执行多次，将子查询划分为  相关(或关联)子查询  和  不相关(或非关联)子查询  。

#### 单行子查询

使用比较操作符=，>,>=,<,<=,!=过滤数据

#### 多行子查询

| 操作符 | 含义                                                       |
| ------ | ---------------------------------------------------------- |
| IN     | 等于列表中的 任意一个                                      |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的 某一个 值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的 所有 值比较   |

#### 相关子查询

- 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为  关联子查询  。
- 相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。
  - EXISTS 与 NOT EXISTS关键字
    - 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
    - 如果在子查询中不存在满足条件的行：
      - 条件返回 FALSE 
      - 继续在子查询中查找
    - 如果在子查询中存在满足条件的行：
      - 不在子查询中继续查找 
      - 条件返回 TRUE
    - NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。

## DML的非DQL

### 插入数据

- VALUES的方式添加

  - 为表的所有字段按默认顺序插入数据

    - INSERT INTO 表名 VALUES (value1,value2,....);
    - 值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。

  - 为表的指定字段插入数据

    - INSERT INTO 表（列名1，列名2，列名3）values（值1，值2，值3）
    - 为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的 默认值。
    - 在 INSERT 子句中可以以任意的顺序列出列名，但是一旦列出，VALUES中要插入的value1,....valuen需要与 column1,...columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。

  - 同时插入多条记录

    - INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔 开

    - ```mysql
      INSERT INTO table_name 
      VALUES
      (value1 [,value2, …, valuen]), 
      (value1 [,value2, …, valuen]),
      ……
      (value1 [,value2, …, valuen]);
      或
      INSERT INTO table_name(column1 [, column2, …, columnn]) 
      VALUES
      (value1 [,value2, …, valuen]), 
      (value1 [,value2, …, valuen]),
      ……
      (value1 [,value2, …, valuen]);
      ```

      

    - 使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息

      - Records：表明插入的记录条数。 
      - Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。
      - Warnings：表明有问题的数据值，例如发生数据类型转换。

    - 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句 在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句 快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。

    - VALUES 也可以写成  VALUE ，但是VALUES是标准写法。 

    - 字符和日期型数据应包含在单引号中。

- 将查询结果插入到表中

  - INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需 要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入 多行。

  - ```mysql
    INSERT INTO 目标表名
    (tar_column1 [, tar_column2, …, tar_columnn])
    SELECT
    (src_column1 [, src_column2, …, src_columnn]) 
    FROM 源表名
    [WHERE condition]
    ```

  - 在 INSERT 语句中加入子查询。

    - 不必书写  VALUES  子句。
    - 子查询中的值列表应与 INSERT 子句中的列名对应。

### 更新数据

- 使用 UPDATE 语句更新数据。

  - ```mysql
    UPDATE table_name
    SET column1=value1, column2=value2, … , column=valuen 
    [WHERE condition]
    ```

  - 可以一次更新 多条 数据。

  - 如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;

  - 如果省略 WHERE 子句，则表中的所有数据都将被更新。

### 删除数据

- 使用 DELETE 语句从表中删除数据

  - ```mysql
    DELETE FROM table_name [WHERE <condition>];
    ```

  - table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句， DELETE语句将删除表中的所有记录。

  - 使用 WHERE 子句删除指定的记录。

### 计算列

- 某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列 不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。

- 在MySQL 8.0中，CREATE TABLE 和  ALTER TABLE 中都支持增加计算列。

- ```mysql
  CREATE TABLE tb1( id INT,
  a INT,
  b INT,
  c INT GENERATED ALWAYS AS (a + b) VIRTUAL );
  ```

  











## DDL

### 创建数据库

- 方法
  1. CREATE DATABASE 数据库名;
  2. CREATE DATABASE 数据库名    CHARACTER SET 字符集;
  3. CREATE DATABASE IF NOT EXISTS 数据库名;
     - 如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。
- DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删 旧库完成的。

### 使用数据库

- 查看当前所有的数据库
  - SHOW DATABASES; #有一个S，代表多个数据库
- 查看当前正在使用的数据库
  - SELECT DATABASE();  #使用的一个    mysql 中的全局函数
- 查看指定库下所有的表
  - SHOW TABLES FROM 数据库名;
- 查看数据库的创建信息
  - SHOW CREATE DATABASE 数据库名; 或者：SHOW CREATE DATABASE 数据库名\G
- 使用/切换数据库
  - USE 数据库名;

### 修改数据库

- 更改数据库字符集
  - ALTER DATABASE 数据库名    CHARACTER SET 字符集;  #比如：gbk、utf8等

### 删除数据库

- 方式1：删除指定的数据库
  - DROP DATABASE 数据库名;
- 方式2：删除指定的数据库（  推荐  ）
  - DROP DATABASE IF EXISTS 数据库名;

### 创建表

- 必须具备：
  - CREATE TABLE权限 
  - 存储空间

```mysql
1
CREATE TABLE [IF NOT EXISTS] 表名( 
  字段1, 数据类型    [约束条件] [默认值], 
  字段2, 数据类型    [约束条件] [默认值], 
  字段3, 数据类型    [约束条件] [默认值],
……
[表约束条件] );
#加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。
2
#使用 AS subquery 选项， 将创建表和插入数据结合起来
指定的列和子查询中的列要一一对应 通过列名和默认值定义列
```

- 必须指定：
  - 表名
  - 列名(或字段名)，数据类型， 长度 
- 可选指定：
  - 约束条件 
  - 默认值
- 查看数据表结构
  - 在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用  DESCRIBE/DESC 语句查看数据 表结构，也支持使用  SHOW CREATE TABLE 语句查看数据表结构。
  - SHOW CREATE TABLE 表名\G

### 修改表

- 修改表指的是修改数据库中已经存在的数据表的结构。
  - 使用 ALTER TABLE 语句可以实现：
  - 向已有的表中添加列 
    - ALTER TABLE 表名    ADD 【COLUMN】    字段名    字段类型    【FIRST|AFTER 字段名】;
  - 修改现有表中的列 
    - 可以修改列的数据类型，长度、默认值和位置
    - ALTER TABLE 表名    MODIFY 【COLUMN】    字段名1 字段类型    【DEFAULT 默认值】【FIRST|AFTER 字段名 2】;
  - 删除现有表中的列 
  - ALTER TABLE 表名    DROP 【COLUMN】字段名
  - 重命名现有表中的列
    - 使用 CHANGE old_column new_column dataType子句重命名列。
    - ALTER TABLE 表名    CHANGE 【column】    列名    新列名    新数据类型;
  - 重命名现有表
    - RENAME TABLE emp TO myemp;

### 删除表

- 在MySQL中，当一张数据表  没有与其他任何数据表形成关联关系  时，可以将当前数据表直接删除。 
- 数据和结构都被删除
- 所有正在运行的相关事务被提交 
- 所有相关索引被删除
- 语法格式：
  - DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];

###  清空表

- TRUNCATE TABLE语句： 
  - 删除表中所有的数据 
  - 释放表的存储空间
- TRUNCATE TABLE detail_dept;
- TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚 
- RUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但  TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。
  - 说明：TRUNCATE TABLE 在功能上与不带  WHERE 子句的 DELETE 语句相同。
  - DDL 和 DML 的说明
    - DDL的操作一旦执行，就不可回滚。指令SET autocommit = FALSE对DDL操作失效。(因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit = FALSE影响的。)
    - DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DML之前，执行了 SET autocommit = FALSE，则执行的DML操作就可以实现回滚。



