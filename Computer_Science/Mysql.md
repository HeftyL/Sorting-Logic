# 数据库概述

## 背景

- 持久化(persistence)： 把数据保存到可掉电式存储设备中以供之后使用 。大多数情况下，特别是企 业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以”固化” ，而持久化的实现过程大多 通过各种关系数据库来完成。
- 持久化的主要作用是 将内存中的数据存储在关系型数据库中 ，当然也可以存储在磁盘文件、XML数 据文件中。

## 概念

- DB：数据库（Database）
  - 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。
- DBMS：数据库管理系统（Database Management System）
  - 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控 制。用户通过数据库管理系统访问数据库中表内的数据。
- SQL：结构化查询语言（Structured Query Language）
  - 专门用来与数据库通信的语言。
- 数据库与数据库管理系统的关系
  - 数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存 应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。

## 常见数据库对象

| 对象                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 表(TABLE)                   | 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 |
| 数据字典（Data dictionary） | 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看 |
| 约束(CONSTRAINT)            | 执行数据校验的规则，用于保证数据完整性的规则                 |
| 视图(VIEW)                  | 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据       |
| 索引(INDEX)                 | 用于提高查询性能，相当于书的目录                             |
| 存储过程 (PROCEDURE)        | 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境 |
| 存储函数 (FUNCTION)         | 用于完成一次特定的计算，具有一个返回值                       |
| 触发器 (TRIGGER)            | 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的 处理 |

## RDBMS 与 非RDBMS

- 关系型数据库(RDBMS)

  - 这种类型的数据库是  最古老  的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系  （即二维表格形式）。
  - 关系型数据库以  行(row)  和  列(column)  的形式存储数据，以便于用户理解。这一系列的行和列被 称为  表(table)  ，一组表组成了一个库(database)。
  - 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型  来表示。关系型数据库，就是建立在  关系模型  基础上的数据库。
  - SQL 就是关系型数据库的查询语言。

- 非关系型数据库(非RDBMS)

  - 相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和 列存储等，除此以外还包括图形数据库。也只有用  NoSQL 一词才能将这些技术囊括进来。

  - 键值型数据库
  - 文档型数据库
  - 搜索引擎数据库
  - 列式数据库
  - 图形数据库

## 关系型数据库设计规则

- 关系型数据库的典型数据结构就是  数据表  ，这些数据表的组成都是结构化的（Structured）。 
- 将数据放到表中，表再放到库中。
- 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 
- 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。

### 表、记录、字段

- E-R（entity-relationship，实体-联系）模型中有三个主要概念是：  实体集  、  属性  、  联系集  。
- 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表 中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。

### 表的关联关系

- 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型来表示。
- 四种：一对一关联、一对多关联、多对多关联、自我引用

#### 一对一

- 在实际的开发中应用不多，因为一对一可以创建成一张表。
- 两种建表原则：
  - 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 
  - 外键是主键：主表的主键和从表的主键，形成主外键关系。

####  一对多

- 一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键

#### 多对多

- 要表示多对多关系，必须创建第三个表，该表通常称为  联接表  ，它将多对多关系划分为两个一对多关 系。将这两个表的主键都插入到第三个表中。

#### 自我引用(Self reference)

# SQL

## 分类

- DDL（Data Definition Languages、数据定义语言） ，这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。
  - 主要的语句关键字包括  CREATE  、  DROP  、  ALTER  等。
- DML（Data Manipulation Language、数据操作语言） ，用于添加、删除、更新和查询数据库记 录，并检查数据完整性。
  - 主要的语句关键字包括  INSERT  、  DELETE  、  UPDATE  、  SELECT  等。 
  - SELECT是SQL语言的基础，最为重要。
- DCL（Data Control Language、数据控制语言） ，用于定义数据库、表、字段、用户的访问权限和 安全级别。
  - 主要的语句关键字包括  GRANT  、  REVOKE  、  COMMIT  、  ROLLBACK  、  SAVEPOINT  等。

- 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（Data Query Language）。
  还有单独将  COMMIT  、  ROLLBACK    取出来称为TCL （Transaction Control Language，事务控制语 言）。

## 规则与规范

### 基本规则

- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 
- 每条命令以 ; 或 \g 或 \G 结束
  关键字不能被缩写也不能分行 
- 关于标点符号
  - 必须保证所有的()、单引号、双引号是成对结束的 
  - 必须使用英文状态下的半角输入方式
  - 字符串型和日期时间类型的数据可以使用单引号（' '）表示 
  - 列的别名，尽量使用双引号（" "），而且不建议省略as

### 大小写规范

- 数据库名、表名、表别名、字段名、字段别名等都小写 
- SQL 关键字、函数名、绑定变量等都大写

### 注 释

- 单行注释：#注释文字(MySQL特有的方式)
- 单行注释：-- 注释文字(--后面必须包含一个空格。) 
- 多行注释：/* 注释文字         */

### 命名规则

- 数据库、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符
- 数据库名、表名、字段名等对象名中间不要包含空格
  同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；
- 同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来
- 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了

### 数据导入指令

- 使用source指令导入

# DML的DQL

## 主体

1. SELECT...

   - ```sql
     SELECT 1; #没有任何子句 
     SELECT 9/2; #没有任何子句
     ```

2. SELECT   标识选择哪些列 FROM     标识从哪个表中选择

3. 选择全部列：SELECT * FROM   departments;

   - 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通 配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。
   - 在生产环境下，不推荐你直接使用  SELECT * 进行查询。

4. 选择特定的列：SELECT department_id, location_id FROM   departments;

   - MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人 员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代 码更容易阅读和维护。

5. 列的别名

   1. 重命名一个列 
   2. 便于计算
   3. 紧跟列名，也可以 在列名和别名之间加入关键字AS，别名使用双引号 ，以便在别名中包含空格或特 殊的字符并区分大小写。
   4. AS 可以省略
   5. 建议别名简短，见名知意

6. 去除重复行

   1. 在SELECT语句中使用关键字DISTINCT去除重复行
   2. SELECT DISTINCT department_id FROM   employees;
   3. DISTINCT 需要放到所有列名的前面，如果写成  SELECT salary, DISTINCT department_id FROM employees 会报错。
   4. DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部 门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需 要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。

7. 空值参与运算

   1. 所有运算符或列值遇到null值，运算的结果都为null
   2. 解决方案使用IFNULL（num1，num2）如果num1不为null则使用num1，num1为null则使用num2
   3. 这里你一定要注意，在 MySQL 里面，  空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长 度是空。而且，在 MySQL 里面，空值是占用空间的。

8. 着重号

   1. 错误的:SELECT * FROM ORDER;
   2. 正确的：SELECT * FROM `‘ORDER’`;
   3. 我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对``（着重号）引起来。

9. 查询常数

   1. SELECT 查询还可以对常数进行查询。就是在 SELECT 查询结果中增加一列固定的常数列。这列的 取值是我们指定的，而不是从数据表中动态取出的。
   2. SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个 固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。
   3. 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段  corporation ，这个 字段固定值为“corporation1”
      1. SELECT 'corporation1' as corporation, last_name FROM employees; 

10. 显示表结构

    1. 使用DESCRIBE 或 DESC 命令，表示表结构。
       1. DESCRIBE employees; 或DESC employees;
          1. Field：表示字段名称。
          2. Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 
          3. Null：表示该列是否可以存储NULL值。
          4. Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；
          5. UNI表示该列是UNIQUE索引的一 部分；
          6. MUL表示在列中某个给定值允许出现多次。
          7. Default：表示该列是否有默认值，如果有，那么值是多少。
          8. Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。

11. 过滤数据

    1. SELECT 字段1,字段2 FROM 表名 WHERE 过滤条件

    2. 使用WHERE 子句，将不满足条件的行过滤掉 WHERE子句紧随 FROM子句

       1. ```sql
          SELECT employee_id, last_name, job_id, department_id 
          FROM   employees
          WHERE department_id = 90 ;
          ```

## 运算符

### 算术运算符

| 运算符 | 名称              | 作用                     | 示例                      |
| ------ | ----------------- | ------------------------ | ------------------------- |
| +      | 加法运算符        | 计算两个值或表达式的和   | SELECTA＋B                |
| -      | 减法运算符        | 计算两个值或表达式的差   | SELECT A- B               |
| *      | 乘法运算符        | 计算两个值或表达式的乘积 | SELECT A*B                |
| /或DIV | 除法运算符        | 计算两个值或表达式的商   | SELECT A/B或SELECTA DIV B |
| %或MOD | 求模(求余）运算符 | 计算两个值或表达式的余数 | SELECT A MOD B            |

### 加法与减法运算符

- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；
- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数 值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）

### 乘法与除法运算符

- 一个数乘以整数1和除以整数1后仍得原数；
- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；
- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；
- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位； 
- 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。

求模（取余）运算符

### 比较运算符

| 运算符 | 名称           | 作用                                                         | 示例                            |
| ------ | -------------- | ------------------------------------------------------------ | ------------------------------- |
| =      | 等于运算符     | 判断两个值、字符串或表达式是否相等                           | SELECT C FROM TABLE WHERE A =B  |
| <=>    | 安全等于运算符 | 安全地判断两个值、字符串或表达式是否相等                     | SELECT C FROM TABLE WHEREA<=> B |
| <>(!=) | 不等于运算符   | 判断两个值、字符串或表达式是否不相等                         | SELECT C FROM TABLE WHEREA<> B  |
| <      | 小于运算符     | 判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA< B   |
| <=     | 小于等于运算符 | 判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA<=B   |
| >      | 大于运算符     | 判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA> B   |
| >=     | 大于等于运算符 | 判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式 | SELECT C FROM TABLE WHEREA> =B  |

### 等号运算符（=）

- 判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回 0。
- 在使用等号运算符时，遵循如下规则：
  - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等。
  - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。
  - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
  - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。
- 对比：SQL中赋值符号使用  :=

### 安全等于运算符

安全等于运算符（<=>）与等于运算符（=）的作用是相似的， 唯一的区别 是‘<=>’可 以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL 时，其返回值为0，而不为NULL。

### 非符号类型运算符

| 运算符                        | 名称             | 作用                                   | 示例                                                         |
| ----------------------------- | ---------------- | -------------------------------------- | ------------------------------------------------------------ |
| IS NULL                       | 为空运算符       | 判断值或表达式是否为空                 | SELECT 1 IS NULL,NULL IS NULL;                               |
| IS NOT NULL                   | 不为空运算符     | 判断值或表达式是否不为空               | SELECT I IS NOT NULL,NULL IS NOT NULL;                       |
| LEAST                         | 最小运算符       | 在多个值里面返回最小值                 | SELECT LEAST(‘A’,‘G’,‘P’);                                   |
| BETWEEN 数字下限 AND 数字上限 | 两者之间运算符   | 在下限和上限之间取值                   | SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000; |
| IN                            | 属于运算符       | 判断值或者表达式是否是列表中的一个值   | SELECT 1 IN(1,2,3);                                          |
| NOT IN                        | 不属于运算符     | 判断表达式或者值是否不是列表中的一个值 | SELECT 2 NOT IN(1,2,3);                                      |
| LIKE                          | 模糊匹配运算符   | 判断一个值是否符合模糊匹配规则         | SELECT * FROM employees WHERE last_name LIKE ‘%a%’;          |
| REGEXP                        | 正则表达式运算符 | 判断一个值是否符合正则表达式规则       | SELECT ‘xykstart’ REGEXP ‘^x’,‘xykstart’ REGEXP ‘$t’,‘xykstart’ REGEXP ‘st’, |
| RLIKE                         | 正则表达式运算符 | 判断一个值是否符合正则表达式规则       | SELECT ‘zzzz’ RLIKE ‘^z’;                                    |

#### 1、空运算符

- 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0

#### 2、非空运算符

- 非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。

#### 3、小值大值运算符

- 语法格式为：LEAST(值1，值2，…，值n)。

- 其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回 小值。
- 语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。
- 当有两个或多个参数时，返回值为 大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。

#### 4、BETWEEN AND 运算符

- BETWEEN运算符使用的格式通常为 `SELECT D FROM TABLE WHERE C BETWEEN A AND B` ，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。
- 在使用 BETWEEN AND 运算符时，结果集中包含查询边界。

#### 5、IN 运算符

- IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。

#### 6、NOT IN 运算符

- NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。有 NULL 参与结果就是 NULL

#### 7、LIKE 模糊运算符

- LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。
- LIKE 运算符使用以下通配符：
- % ->：匹配任意多个字符（0-n）
- _ ->：当一个占位符的使

#### 8、ESCAPE 关键字

- 如果在使用转义符时不想使用 \ 下划线做转义符，就能使用 ESCAPE 关键字声明一个符号为转义符。
- 使用 \ 下划线就可以省略这个步骤。

#### 9、REGEXP 运算符

- 正则表达式（英语：Regular Expression，常简写为regex、regexp或RE）。
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串

- 基本字符匹配

  - 检索列 column包含文本text的所有行：where column regexp ‘text’

  - . :点. 是正则表示式中一个特殊的字符。它表示匹配任意一个字符，相当于通配符_


- 区分大小写

  - mysql默认不区分大小写，提供使用Binary关键字区分 Regexp Binary ‘ Text ’

- 进行or匹配

  - 搜索多个字符串之一，使用 | ，Regexp ‘text1 | text2’

- 匹配几个字符之一

  - []：[]是另一种形式的or语句，是|的缩写
  - ' [123]num '='[1|2|3]num '='1num|2num|3num'

- 匹配范围

  - [0-9] ,[a-z],[1-3]

- 匹配特殊字符

  - 匹配具有特殊含义的字符 
    - 查找- ：\\-
    - 匹配\ ：\\\
    - 空白元字符
      - \f：换页
      - \n：换行
      - \r：回车
      - \t：制表
      - \v: 纵向制表
      - 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身，但是MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。

- 匹配多个实例

  - 重复元字符：
  - *：0个或多个匹配
  - +：1个或多个 匹配（相当于{1，}）
  - ？：0个或一个匹配（相当于{0,1}）
  - {n}：指定数目的匹配
  - {n，}：不少于指定数目的匹配
  - {n，m}：匹配数目的范围（m不超过255）
    - 匹配连在一起的四位数字： '[[:digit:]]{4}'

- 定位符

  ```mysql
  定位元字符：
  ^:文本的开始
  $:文本的结束
  [[:<:]]:词的开始
  [[:>:]]:词的末尾
  ```

  - ^ 符号的双重用途： ^在集合中（用 [ ] 定义）时用它来否定该集合，否则用来指定串的开始处。
  - 词的匹配分别匹配一个单词开头和结尾的空的字符串，这个单词开头和结尾都不是包含在alnum中的字符也不能是下划线。(alnum表示英文字母和数字字符)

- 匹配字符类

  ```mysql
  [:alpha:]	：匹配当前归类中的大写和小写字母字符。例如，'[0-9]{3}[[:alpha:]]{2}' 匹配三个数字，后跟两个字母。
  
  [:alnum:]	：匹配当前归类中的数字、大写和小写字母字符。例如，'[[:alnum:]]+' 匹配含有一个或多个字母和数字的字符串。
  
  [:digit:]	：匹配当前归类中的数字。例如，'[[:digit:]-]+' 匹配含有一个或多个数字或横线的字符串。同样，'[^[:digit:]-]+' 匹配含有一个或多个不是数字或横线的字符的字符串。
  
  [:lower:]	：匹配当前归类中的小写字母字符。例如，'[[:lower:]]' 不匹配 A，因为 A 为大写。
  
  [:space:]	：匹配单个空格 (' ')。例如，搜索 Contacts.City 以查找任何名称为两个词的城市：
  [:upper:]	：匹配当前归类中的大写字母字符。例如，'[[:upper:]ab]' 与以下其中一项匹配：任何大写字母、a 或 b。
  
  [:whitespace:]	：匹配一个空白字符，例如，空格、制表符、换页符和回车符。
  
  [:ascii:]	：匹配任何七位的 ASCII 字符（0 到 127 之间的顺序值）。
  
  [:blank:]	：匹配一个空白区或水平制表符。
  
  [:blank:] 等效于 [ \t]。
  
  [:cntrl:]	：匹配顺序值小于 32 或字符值为 127 的 ASCII 字符（控制字符）。控制字符包括换行符、换页符、退格符，等等。
  
  [:graph:]	：匹配打印字符。
  
  [:graph:]  ：等效于 [[:alnum:][:punct:]]。
  
  [:print:]	：匹配打印字符和空格。
  
  [:print:] ：等效于 [[:graph:][:whitespace:]]。
  
  [:punct:]	：匹配其中一个字符： !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~.
  
  [:punct:] 子字符类不能包括当前归类中可用的非 ASCII 标点字符。
  
  [:word:]	：匹配当前归类中的字母、数字或下划线字符。
  
  [:word:] 等效于 [[:alnum:]_]。
  
  [:xdigit:]	：匹配字符类 [0-9A-Fa-f] 中的字符。
  ```

### 逻辑运算符

| 运算符      | 作用     |
| ----------- | -------- |
| NOT 或者 !  | 逻辑非   |
| AND 或者 && | 逻辑与   |
| OR 和 \|\|  | 逻辑或   |
| XOR         | 逻辑异或 |

- 逻辑非运算符  逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0； 当给定的值为NULL时，返回NULL。
- 逻辑与运算符  逻辑与（AND或&&）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回 1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。
- 逻辑或运算符  逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返 回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为 NULL时，返回NULL。
  - OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先 对AND两边的操作数进行操作，再与OR中的操作数结合。
- 逻辑异或运算符  逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果 两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。

### 位运算符

| 运算符 | 说明   | 使用形式 | 举例                             |
| ------ | ------ | -------- | -------------------------------- |
| \|     | 位或   | a \| b   | 5 \| 8                           |
| &      | 位与   | a & b    | 5 & 8                            |
| ^      | 位异或 | a ^ b    | 5 ^ 8                            |
| ~      | 位取反 | ~a       | ~5                               |
| <<     | 位左移 | a << b   | 5 << 2，表示整数 5 按位左移 2 位 |
| >>     | 位右移 | a >> b   | 5 >> 2，表示整数 5 按位右移 2 位 |

- 按位与运算符  按位与（&）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。

- 按位或运算符  按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的 二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。

- 按位异或运算符  按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值 对应的二进制位的数值不同时，则该位返回1，否则返回0。

- 按位取反运算符  按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。

  - ```mysql
    mysql> SELECT 10 & ~1;
    +---------+
    | 10 & ~1 |
    +---------+ 
    |      10 | 
    +---------+
    1 row in set (0.00 sec)
    ```

    

  - 由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1，首先，对数字1进 行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。

- 按位右移运算符  按位右移（>>）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。

- 按位左移运算符  按位左移（<<）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。

###  运算符的优先级

| 优先级由低到高排列 | 运算符                                                       |
| ------------------ | ------------------------------------------------------------ |
| 1                  | =(赋值运算）、:=                                             |
| 2                  | II、OR                                                       |
| 3                  | XOR                                                          |
| 4                  | &&、AND                                                      |
| 5                  | NOT                                                          |
| 6                  | BETWEEN、CASE、WHEN、THEN、ELSE                              |
| 7                  | =(比较运算）、<=>、>=、>、<=、<、<>、!=、 IS、LIKE、REGEXP、IN |
| 8                  | \|                                                           |
| 9                  | &                                                            |
| 10                 | <<、>>                                                       |
| 11                 | -(减号）、+                                                  |
| 12                 | *、/、%                                                      |
| 13                 | ^                                                            |
| 14                 | -(负号）、〜（位反转）                                       |
| 15                 | !                                                            |

## 排序

- 使用 ORDER BY 子句排序
  - ASC（ascend）: 升序 DESC（descend）:降序
  - ORDER BY 子句在SELECT语句的结尾。
  - 列的别名只能在where子句之后使用
- 单列排序
  - ORDER BY 列1;
- 多列排序
  - ORDER BY 列1，列2;

## 分页

- 分页原理
  - 所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。
  - MySQL中使用 LIMIT 实现分页
- 格式：LIMIT [位置偏移量,] 行数
  - 第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移 量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）；第二个参数“行数”指示返回的记录条数。
  - MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。
  - 注意：LIMIT 子句必须放在整个SELECT语句的最后！
  - 约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。

## 多表查询

- 笛卡尔积（或交叉连接）的理解

  - 笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能 组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素 个数的乘积数。
  - 笛卡尔积的错误会在下面条件下产生 ：
    - 省略多个表的连接条件（或关联条件） 连接条件（或关联条件）无效
    - 所有表中的所有行互相连接
    - 为了避免笛卡尔积， 可以 在 WHERE 加入有效的连接条件。

- 等值连接

  - 多个表中有相同列时，必须在列名之前加上表名前缀。 在不同表中具有相同列名的列可以用 表名 加以区分。
  - 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替， 不能使用原有的表名，否则就会报错。
  - 【  强制  】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。
  - 说明  ：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表 名），并且操作列在多个表中存在时，就会抛异常。
  - 正例  ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;
  - 反例 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年 后，最近在 某个表中增加一个同名字段，在预发布环境数据库变更后，线上查询语句出现出 1052 异常：Column 'name' in field list is ambiguous。
  - 连接  n个表,至少需要n-1个连接条件

- 自连接

  - 当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两 个表再进行内连接，外连接等查询。

- 外连接

  - 除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。

  - 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行 

  - 外连接: 两个表在连接过程中除了返回满足连接条件的行以外 还返回左（或右）表中不满足条件的行   ，这种连接称为左（或右） 外连接 。没有匹配的行时, 结果表中相应的列为空(NULL)。 

  - 如果是左外连接，则连接条件中左边的表也称为  主表  ，右边的表称为  从表  。
    如果是右外连接，则连接条件中右边的表也称为  主表  ，左边的表称为  从表  。

  - 左外连接(LEFT OUTER JOIN)

    - ```mysql
      #实现查询结果是A
      SELECT 字段列表
      FROM A表    LEFT JOIN B表 ON 关联条件
      WHERE 等其他子句;
      ```

  - 右外连接(RIGHT OUTER JOIN)

    - ```mysql
      #实现查询结果是B
      SELECT 字段列表
      FROM A表    RIGHT JOIN B表 ON 关联条件
      WHERE 等其他子句;
      ```

  - 满外连接(FULL OUTER JOIN)

    - 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。
    - 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION  RIGHT join代替。

## 内置函数

### 单行函数

- 操作数据对象
- 接受参数返回一个结果
- 只对一行进行变换 每行返回一个结果
- 可以嵌套
- 参数可以是一列或一个值

#### 数值函数

| 函数          | 功能                             |
| ------------- | -------------------------------- |
| ABS（x）      | 返回x的绝对值                    |
| CEIL（x）     | 返回大于x的最小整数值            |
| FLOOR(x)      | 返回小于x的最大整数值            |
| MOD（x/y）    | 返回x/y的模                      |
| RAND()        | 返回0-1的随机数                  |
| ROUND(x,y)    | 返回参数x的四舍五入的y位小数的值 |
| TRUNCATE(x,y) | 返回数字x截断为y位小数的结果     |

#### 时间函数

| 函数                              | 功能                                         |
| --------------------------------- | -------------------------------------------- |
| CURDATE()                         | 返回当前日期                                 |
| CURTIME()                         | 返回当前时间                                 |
| NOW()                             | 返回当前的时间                               |
| UNIX_TIMESTAMP(date)              | 返回日期date的UNIX时间戳                     |
| FROM_UNIXTIME                     | 返回UNIX时间戳的日期值                       |
| WEEK(date)                        | 返回日期date为一年中的第几周                 |
| YEAR（date）                      | 返回日期date的年份                           |
| HOUR(time)                        | 返回time的小时值                             |
| MINUTE(time)                      | 返回time的分钟值                             |
| MONTHNAME(date)                   | 返回date的月份名                             |
| DATE_FORMAT(date,fmt)             | 返回字符串fmt格式化日期date值                |
| DATE_ADD(date,INTERVAL expr type) | 返回一个日期或时间值加上一个时间间隔的时间值 |
| DATEDIFF(expr,expr2)              | 返回起始时间expr和结束时间expr2之间的天数    |

#### 字符串函数

| 函数          | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| Left（）      | 返回串左边的字符                                             |
| length（）    | 返回串的长度                                                 |
| locate（）    | 找出串的一个子串                                             |
| lower（）     | 将串转换为小写                                               |
| Upper（）     | 将串转换为大写                                               |
| LTrim（）     | 去除串左边的空格                                             |
| Right（）     | 返回串的右边的字符                                           |
| Rtrim（）     | 去掉右边的空格                                               |
| Soundex（）   | 返回串的Soundex值，Soundex是一个将任何文本串转换为描述器语音表示的字母数字模式的算法 |
| SubString（） | 返回子串的字符                                               |
| Upper（）     | 将串转换为大写                                               |

#### 流程控制函数

| 函数                                                         | 功能                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| IF(value,value1,value2)                                      | 如果value的值为TRUE，返回value1， 否则返回value2 |
| IFNULL(value1, value2)                                       | 如果value1不为NULL，返回value1，否 则返回value2  |
| CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 .... [ELSE resultn] END | 相当于Java的if...else if...else...               |
| CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END | 相当于Java的switch...case...                     |

#### 加密与解密函数

| 函数                        | 功能                                                         |
| --------------------------- | ------------------------------------------------------------ |
| PASSWORD(str)               | 返回字符串str的加密版本，41位长的字符串。加密结果  不可 逆  ，常用于用户的密码加密 |
| MD5(str)                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL |
| SHA(str)                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。  SHA加密算法比MD5更加安全  。 |
| ENCODE(value,password_seed) | 返回使用password_seed作为加密密码加密value                   |
| DECODE(value,password_seed) | 返回使用password_seed作为加密密码解密value                   |

#### MySQL信息函数

| 函数                                                   | 功能                                                   |
| ------------------------------------------------------ | ------------------------------------------------------ |
| VERSION()                                              | 返回当前MySQL的版本号                                  |
| CONNECTION_ID()                                        | 返回当前MySQL服务器的连接数                            |
| DATABASE()，SCHEMA()                                   | DATABASE()，SCHEMA()                                   |
| USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() | USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() |
| CHARSET(value)                                         | 返回字符串value自变量的字符集                          |
| COLLATION(value)                                       | 返回字符串value的比较规则                              |

#### 其他函数

| 函数                           | 功能                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| FORMAT(value,n)                | 返回对数字value进行格式化后的结果数据。n表示  四舍五入  后保留 到小数点后n位 |
| CONV(value,from,to)            | CONV(value,from,to)                                          |
| INET_ATON(ipvalue)             | 将以点分隔的IP地址转化为一个数字                             |
| INET_NTOA(value)               | 将数字形式的IP地址转化为以点分隔的IP地址                     |
| BENCHMARK(n,expr)              | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 |
| CONVERT(value USING char_code) | 将value所使用的字符编码修改为char_code                       |

### 多行函数（聚集）

- 聚合函数作用于一组数据，并对一组数据返回一个值。
- 聚集函数(aggregate function)
- 利用算术操作符可以用来执行多个列上的计算
- 只包含不同的值，指定Distinct参数
  - All为默认参数
  - Distinct不能用于Count（*）
- 运行在行组上，计算和返回单个值的函数
  - AVG（）
    - 返回某列的平均值
    - Avg（）只能确定特定数值列的平均值，而且列名必须作为函数参数给出。多个列的值需使用多个Avg（）函数
    - Avg（）函数忽略列值为null的行
  - Count（）
    - 返回某列的行数
    - 如果参数指定列名，null值被忽略。如果参数为*不忽略null值，对表中行的数目进行计数
  - Max（）
    - 返回某列的最大值
    - 忽略null值
    - 文本数据，如果数据按相应的列排序，返回最后面的行
  - Min（）
    - 返回某列的最小值
    - 文本数据，如果数据按相应的列排序，返回最前面的行
    - 忽略null值
  - Sum
    - 返回某列值之和
    - 忽略null值

#### Count

- 用count(*)，count(1)，count(列名)谁好呢?
  - 其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。
  - Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。
- 能不能使用count(列名)替换count(*)?*
- *不要使用 count(列名)来替代    count(*) ，  count(*) 是  SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。*
- 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为  NULL 值的行。

#### GROUP BY子句

- 可以使用GROUP BY子句将表中的数据分成若干组

```mysql
SELECT column, group_function(column) 
FROM table
[WHERE condition]
[GROUP BY  group_by_expression] 
[ORDER BY  column];
```

- WHERE一定放在FROM后面

- 在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中

  - 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中

- 多个列分组

  - ```mysql
    SELECT   department_id dept_id, job_id, SUM(salary) 
    FROM     employees
    GROUP BY department_id, job_id ;
    ```

- GROUP BY中使用WITH ROLLUP

  - 使用  WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所 有记录的总和，即统计记录数量。

#### HAVING子句

- 过滤分组：HAVING子句

  - 行已经被分组。

  - 使用了聚合函数。

  - 满足HAVING 子句中条件的分组将被显示。

  - HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。

- WHERE和HAVING的对比

  - 区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。

    - 这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。

  - 区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。

    -  这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。

  - |        | 优点                         | 缺点                                   |
    | ------ | ---------------------------- | -------------------------------------- |
    | WHERE  | 先筛选数据再关联，执行效率高 | 不能使用分组中的计算函数进行筛选       |
    | HAVING | 可以使用分组中的计算函数     | 在最后的结果集中进行筛选，执行效率较低 |



#####  执行过程

- 方式1：
  - SELECT ...,....,... 
  - FROM ...,...,.... 
  - WHERE 多表的连接条件 AND 不包含组函数的过滤条件 
  - GROUP BY ...,... 
  - HAVING 包含组函数的过滤条件 
  - ORDER BY ... ASC/DESC 
  - LIMIT ...,...
- 方式2：
  - SELECT ...,....,... 
  - FROM ... JOIN ... ON 多表的连接条件
  - JOIN ... ON ...
    WHERE 不包含组函数的过滤条件 AND/OR 不包含组函数的过滤条件
  - GROUP BY ...,...
    HAVING 包含组函数的过滤条件 
  - ORDER BY ... ASC/DESC 
  - LIMIT ...,...

- 顺序：

  - （1）from：从哪些表中筛选

  - （2）on：关联多表查询时，去除笛卡尔积

  - （3）where：从表中筛选的条件

  - （4）group by：分组依据

  - （5）having：在统计结果中再次筛选

  - （6）order by：排序

  - （7）limit：分页

- SELECT执行顺序

  - 关键字的顺序是不能颠倒的：
    - SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...
  - SELECT 语句的执行顺序 （在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：
    - FROM -> WHERE -> GROUP BY -> HAVING -> SELECT 的字段    -> DISTINCT -> ORDER BY -> LIMIT

- 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个  虚拟表  ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在  SQL 的执行过程中，对于我们来说是不可见的。

- SQL 的执行原理

  - SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
    1.   首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
    2.   通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
    3.   添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。
  - 当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。
  - 我们拿到了查询数据表的原始数据，也就是最终的虚拟表    vt1 ，就可以在此基础上再进行    WHERE 阶 段  。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表    vt2 。
  - 然后进入第三步和第四步，也就是    GROUP 和     HAVING 阶段  。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表    vt3 和    vt4 。
  - 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到    SELECT 和     DISTINCT 阶段  。
  - 首先在 SELECT 阶段会提取想要的字段，然后在  DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和    vt5-2 。
  - 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是    ORDER BY 阶段  ，得到 虚拟表    vt6 。
  - 最后在 vt6 的基础上，取出指定行的记录，也就是    LIMIT 阶段  ，得到最终的结果，对应的是虚拟表 vt7 。
  - 当然我们在写  SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。
  - 同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序， 所谓底层运行的原理，就是我们刚才讲到的执行顺序。



## 子查询

- 子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。
- SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者 需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集 合）进行比较。
- 子查询（内查询）在主查询之前一次执行完成。 
- 子查询的结果被主查询（外查询）使用 。
- 分类
  - 按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。
  - 按内查询是否被执行多次，将子查询划分为  相关(或关联)子查询  和  不相关(或非关联)子查询  。

### 单行子查询

使用比较操作符=，>,>=,<,<=,!=过滤数据

### 多行子查询

| 操作符 | 含义                                                       |
| ------ | ---------------------------------------------------------- |
| IN     | 等于列表中的 任意一个                                      |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的 某一个 值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的 所有 值比较   |

### 相关子查询

- 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件 关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为  关联子查询  。
- 相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。
  - EXISTS 与 NOT EXISTS关键字
    - 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
    - 如果在子查询中不存在满足条件的行：
      - 条件返回 FALSE 
      - 继续在子查询中查找
    - 如果在子查询中存在满足条件的行：
      - 不在子查询中继续查找 
      - 条件返回 TRUE
    - NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。

# DML的非DQL

## 插入数据

- VALUES的方式添加

  - 为表的所有字段按默认顺序插入数据

    - INSERT INTO 表名 VALUES (value1,value2,....);
    - 值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。

  - 为表的指定字段插入数据

    - INSERT INTO 表（列名1，列名2，列名3）values（值1，值2，值3）
    - 为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的 默认值。
    - 在 INSERT 子句中可以以任意的顺序列出列名，但是一旦列出，VALUES中要插入的value1,....valuen需要与 column1,...columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。

  - 同时插入多条记录

    - INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔 开

    - ```mysql
      INSERT INTO table_name 
      VALUES
      (value1 [,value2, …, valuen]), 
      (value1 [,value2, …, valuen]),
      ……
      (value1 [,value2, …, valuen]);
      或
      INSERT INTO table_name(column1 [, column2, …, columnn]) 
      VALUES
      (value1 [,value2, …, valuen]), 
      (value1 [,value2, …, valuen]),
      ……
      (value1 [,value2, …, valuen]);
      ```

      

    - 使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息

      - Records：表明插入的记录条数。 
      - Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。
      - Warnings：表明有问题的数据值，例如发生数据类型转换。

    - 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句 在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句 快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。

    - VALUES 也可以写成  VALUE ，但是VALUES是标准写法。 

    - 字符和日期型数据应包含在单引号中。

- 将查询结果插入到表中

  - INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需 要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入 多行。

  - ```mysql
    INSERT INTO 目标表名
    (tar_column1 [, tar_column2, …, tar_columnn])
    SELECT
    (src_column1 [, src_column2, …, src_columnn]) 
    FROM 源表名
    [WHERE condition]
    ```

  - 在 INSERT 语句中加入子查询。

    - 不必书写  VALUES  子句。
    - 子查询中的值列表应与 INSERT 子句中的列名对应。

## 更新数据

- 使用 UPDATE 语句更新数据。

  - ```mysql
    UPDATE table_name
    SET column1=value1, column2=value2, … , column=valuen 
    [WHERE condition]
    ```

  - 可以一次更新 多条 数据。

  - 如果需要回滚数据，需要保证在DML前，进行设置： SET AUTOCOMMIT = FALSE;

  - 如果省略 WHERE 子句，则表中的所有数据都将被更新。

## 删除数据

- 使用 DELETE 语句从表中删除数据

  - ```mysql
    DELETE FROM table_name [WHERE <condition>];
    ```

  - table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句， DELETE语句将删除表中的所有记录。

  - 使用 WHERE 子句删除指定的记录。

## 计算列

- 某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列 不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。

- 在MySQL 8.0中，CREATE TABLE 和  ALTER TABLE 中都支持增加计算列。

- ```mysql
  CREATE TABLE tb1( id INT,
  a INT,
  b INT,
  c INT GENERATED ALWAYS AS (a + b) VIRTUAL );
  ```

# DDL

## 创建数据库

- 方法
  1. CREATE DATABASE 数据库名;
  2. CREATE DATABASE 数据库名    CHARACTER SET 字符集;
  3. CREATE DATABASE IF NOT EXISTS 数据库名;
     - 如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。
- DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删 旧库完成的。

## 使用数据库

- 查看当前所有的数据库
  - SHOW DATABASES; #有一个S，代表多个数据库
- 查看当前正在使用的数据库
  - SELECT DATABASE();  #使用的一个    mysql 中的全局函数
- 查看指定库下所有的表
  - SHOW TABLES FROM 数据库名;
- 查看数据库的创建信息
  - SHOW CREATE DATABASE 数据库名; 或者：SHOW CREATE DATABASE 数据库名\G
- 使用/切换数据库
  - USE 数据库名;

## 修改数据库

- 更改数据库字符集
  - ALTER DATABASE 数据库名    CHARACTER SET 字符集;  #比如：gbk、utf8等

## 删除数据库

- 方式1：删除指定的数据库
  - DROP DATABASE 数据库名;
- 方式2：删除指定的数据库（  推荐  ）
  - DROP DATABASE IF EXISTS 数据库名;

## 创建表

- 必须具备：
  - CREATE TABLE权限 
  - 存储空间

```mysql
1
CREATE TABLE [IF NOT EXISTS] 表名( 
  字段1, 数据类型    [约束条件] [默认值], 
  字段2, 数据类型    [约束条件] [默认值], 
  字段3, 数据类型    [约束条件] [默认值],
……
[表约束条件] );
#加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。
2
#使用 AS subquery 选项， 将创建表和插入数据结合起来
CREATE TABLE emp1 AS SELECT * FROM employees;
指定的列和子查询中的列要一一对应 通过列名和默认值定义列
```

- 必须指定：
  - 表名
  - 列名(或字段名)，数据类型， 长度 
- 可选指定：
  - 约束条件 
  - 默认值
- 查看数据表结构
  - 在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用  DESCRIBE/DESC 语句查看数据 表结构，也支持使用  SHOW CREATE TABLE 语句查看数据表结构。
  - SHOW CREATE TABLE 表名\G

## 修改表

- 修改表指的是修改数据库中已经存在的数据表的结构。
  - 使用 ALTER TABLE 语句可以实现：
  - 向已有的表中添加列 
    - ALTER TABLE 表名    ADD 【COLUMN】    字段名    字段类型    【FIRST|AFTER 字段名】;
  - 修改现有表中的列 
    - 可以修改列的数据类型，长度、默认值和位置
    - ALTER TABLE 表名    MODIFY 【COLUMN】    字段名1 字段类型    【DEFAULT 默认值】【FIRST|AFTER 字段名 2】;
  - 删除现有表中的列 
  - ALTER TABLE 表名    DROP 【COLUMN】字段名
  - 重命名现有表中的列
    - 使用 CHANGE old_column new_column dataType子句重命名列。
    - ALTER TABLE 表名    CHANGE 【column】    列名    新列名    新数据类型;
  - 重命名现有表
    - RENAME TABLE emp TO myemp;

## 删除表

- 在MySQL中，当一张数据表  没有与其他任何数据表形成关联关系  时，可以将当前数据表直接删除。 
- 数据和结构都被删除
- 所有正在运行的相关事务被提交 
- 所有相关索引被删除
- 语法格式：
  - DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];

##  清空表

- TRUNCATE TABLE语句： 
  - 删除表中所有的数据 
  - 释放表的存储空间
- TRUNCATE TABLE detail_dept;
- TRUNCATE语句 不能回滚 ，而使用 DELETE 语句删除数据，可以回滚 
- RUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但  TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。
  - 说明：TRUNCATE TABLE 在功能上与不带  WHERE 子句的 DELETE 语句相同。
  - DDL 和 DML 的说明
    - DDL的操作一旦执行，就不可回滚。指令SET autocommit = FALSE对DDL操作失效。(因为在执行完DDL操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit = FALSE影响的。)
    - DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DML之前，执行了 SET autocommit = FALSE，则执行的DML操作就可以实现回滚。



# DCL

# 约束

## 背景

- 数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中 存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。

- 为了保证数据的完整性，SQL规范以约束的方式对 表数据进行额外的条件限制 。
  - 实体完整性（Entity Integrity）  ：例如，同一个表中，不能存在两条完全相同无法区分的记录 
  - 域完整性（Domain Integrity）  ：例如：年龄范围0-120，性别范围“男/女”
  - 引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门 
  - 用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门 经理的工资不得高于本部门职工的平均工资的5倍。

## 定义

- 约束是表级的强制规定。
- 可以在 创建表时规定约束（通过 CREATE TABLE 语句） ，或者在 表创建之后通过 ALTER TABLE 语句规定 约束 。

## 分类

- 根据约束数据列的限制， 约束可分为：
  - 单列约束 ：每个约束只约束一列 
  - 多列约束 ：每个约束可约束多列数据
- 根据约束的作用范围 ，约束可分为：
  - 列级约束 ：只能作用在一个列上，跟在列的定义后面 
  - 表级约束 ：可以作用在多个列上，不与列一起，而是单独定义

| 分类     | 位置         | 支持的约束类型             | 是否可以起约束名     |
| -------- | ------------ | -------------------------- | -------------------- |
| 列级约束 | 列的后面     | 语法都支持，但外键没有效果 | 不可以               |
| 表级约束 | 所有列的下面 | 默认和非空不支持，其他支持 | 可以（主键没有效果） |

- 根据约束起的作用 ，约束可分为：
  - NOT NULL 非空约束，规定某个字段不能为空 
  - UNIQUE 唯一约束 ， 规定某个字段在整个表中是唯一的 
  - PRIMARY KEY 主键(非空且唯一)约束
  - FOREIGN KEY 外键约束 
  - CHECK 检查约束
  - DEFAULT 默认值约束
- 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果

## 操作

### 非空约束

- 关键字：NOT NULL

- 限定某个字段/某列的值不允许为空

#### 特点

- 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空 
- 一个表可以有很多列都分别限定了非空
- 空字符串''不等于NULL，0也不等于NULL

#### 添加非空约束

- 建表时

- ```mysql
  CREATE TABLE 表名称( 
    字段名 数据类型,
  	字段名 数据类型 NOT NULL,  
    字段名 数据类型 NOT NULL
  );
  举例
  CREATE TABLE emp(
   	id INT(10) NOT NULL, 
    NAME VARCHAR(20) NOT NULL, 
    sex CHAR NULL
  );
  ```

- 建表后

- ```mysql
  alter table 表名称
  modify 字段名 数据类型 not null;
  举例
  ALTER TABLE emp
  MODIFY sex VARCHAR(30) NOT NULL;
  ```

  

#### 删除非空约束

- ```mysql
  alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允 许为空
  或
  alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空
  举例
  ALTER TABLE emp
  MODIFY sex VARCHAR(30) NULL;
  ```

  

### 唯一性约束

- 用来限制某个字段/某列的值不能重复。
- 关键字：UNIQUE

#### 特点

- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。
- 唯一性约束允许列值为空。
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
- MySQL会给唯一约束的列上默认创建一个唯一索引。

#### 添加

##### 建表

- ```mysql
  create table 表名称( 
    字段名 数据类型,
  	字段名 数据类型 unique,  
    字段名 数据类型 unique key, 
    字段名 数据类型
  );
  
  create table 表名称( 
    字段名 数据类型,
  	字段名 数据类型,  
    字段名 数据类型, 
    字段名 数据类型，
    [constraint 约束名] unique key(字段名)
  );
  举例
  create table student( sid int,
     sname varchar(20),
     tel char(11) unique,
     cardid char(18) unique key );
  CREATE TABLE USER( 
    id INT NOT NULL, 
    NAME VARCHAR(25), 
    PASSWORD VARCHAR(16), 
    -- 使用表级约束语法
  	CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD) );
  	
  ```

##### 建表后

- ```mysql
  #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯 一的
  #方式1：
  alter table 表名称 add unique key(字段列表);
  #方式2：
  alter table 表名称 modify 字段名 字段类型 unique;
  举例
  ALTER TABLE USER
  ADD UNIQUE(NAME,PASSWORD);
  ALTER TABLE USER
  ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);
  ALTER TABLE USER
  MODIFY NAME VARCHAR(20) UNIQUE;
  ```

##### 复合唯一约束

- ```mysql
  create table 表名称( 
    字段名 数据类型,
    字段名 数据类型,    
    字段名 数据类型,
     unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的
  );
  举例
  create table student_course(    
    id int,
  	sid int,    
    cid int,    
    score int,
     unique key(sid,cid)  #复合唯一 );
  ```

#### 删除

- 添加唯一性约束的列上也会自动创建唯一索引。

- 删除唯一约束只能通过删除唯一索引的方式删除。

- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。

- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和() 中排在第一个的列名相同。也可以自定义唯一性约束名。

- ```mysql
  SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪 些约束
  ALTER TABLE USER
  DROP INDEX uk_name_pwd;
  注意：可以通过 show index from 表名称;  查看表的索引
  ```

### 主键约束

- 用来唯一标识表中的一行记录。
- 关键字：primary key

#### 特点

- 主键约束相当于 唯一约束+非空约束的组合 ，主键约束列不允许重复，也不允许出现空值。
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 
- 主键约束对应着表中的一列或者多列（复合主键）
- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 
- MySQL的主键名总是PRIMARY ，就算自己命名了主键约束名也没用。
- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的 主键索引 （能够根据主键查询 的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。 
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。

#### 添加

##### 建表时指定

```mysql
create table 表名称(
	字段名 数据类型 primary key, #列级模式    
  字段名 数据类型,  
   字段名 数据类型);
create table 表名称( 
  字段名 数据类型,
  字段名 数据类型,
  字段名 数据类型,
  [constraint 约束名] primary key(字段名) #表级模式 );
举例
create table temp(
	id int primary key,    
  name varchar(20) );
CREATE TABLE emp5(
	id INT NOT NULL AUTO_INCREMENT, NAME VARCHAR(20),
	pwd VARCHAR(15),
	CONSTRAINT emp5_id_pk PRIMARY KEY(id) );
```

##### 建表后增加

```mysql
ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多 个字段的话，是复合主键
举例
ALTER TABLE student ADD PRIMARY KEY (sid);
ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);
```

#### 删除

```mysql
alter table 表名称    drop primary key;
举例
ALTER TABLE student DROP PRIMARY KEY;
ALTER TABLE emp5 DROP PRIMARY KEY;
#说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空约束还存在。
```

### 自增约束

- 某个字段的值自增
- 关键字：AUTO_INCREMENT

#### 特点

- ​	一个表最多只能有一个自增长列
- （2）当需要产生唯一标识符或顺序值时，可设置自增长
- （3）自增长列约束的列必须是键列（主键列，唯一键列）
- （4）自增约束的列的数据类型必须是整数类型
- （5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 赋值为具体值

#### 添加

- 建表时

- ```mysql
  create table 表名称(
  	字段名 数据类型 primary key auto_increment,    
    字段名 数据类型 unique key not null,  
    字段名 数据类型 unique key,
    字段名 数据类型 not null default 默认值, );
  举例
  create table employee(
  	eid int primary key auto_increment,    
    ename varchar(20)
  );
  
  ```

- 建表后

- ```mysql
  alter table 表名称 modify 字段名 数据类型 auto_increment;
  alter table employee modify eid int auto_increment;
  ```

#### 删除

```mysql
alter table 表名称    modify 字段名    数据类型    auto_increment;#给这个字段增加自增约束 
alter table 表名称    modify 字段名    数据类型; #去掉auto_increment相当于删除
举例
alter table employee modify eid int;
```

#### 自增变量的持久化

- 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重 置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发 现的问题。 
  - 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。
  - MySQL 8.0将自增主键的计数器持久化到  重做日志  中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。

### 外键约束

- 限定某个表的某个字段的引用完整性。
- 关键字：FOREIGN KEY

#### 特点

- 从表的外键列，必须引用/参考主表的主键或唯一约束的列。因为被依赖/被参考的值必须是唯一的
- 在创建外键约束时，如果不给外键约束命名， 默认名不是列名，而是自动产生一个外键名 （例如 student_ibfk_1;），也可以指定外键约束名。
- 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表
- 删表时，先删从表（或先删除外键约束），再删除主表
- 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖 该记录的数据，然后才可以删除主表的数据
- 在“从表”中指定外键约束，并且一个表可以建立多个外键约束
- 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类 型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。

- 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引 。但是索引名是外键的约束 名。（根据外键查询效率很高）
- 删除外键约束后，必须  手动  删除对应的索引

#### 约束等级

- 如果没有指定等级，就相当于Restrict方式。

| 等级          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| Cascade方式   | 在父表上update/delete记录时，同步update/delete掉子表的匹配记录 |
| Set null方式  | 在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null |
| No action方式 | 如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作 |
| Restrict方式  | 同no action， 都是立即检查外键约束                           |
| Set default   | （在可视化工具SQLyog中可能显示空白），父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别 |
| 方式          |                                                              |

- 对于外键约束，最好是采用:  ON UPDATE CASCADE ON DELETE RESTRICT 的方式。

- ```mysql
  create table emp(#从表
    eid int primary key,  #员工编号    
    ename varchar(5),     #员工姓名
    deptid int,           #员工所在的部门
    foreign key (deptid) references dept(did)  on update cascade on delete set null    
    #把修改操作设置为级联修改等级，把删除操作设置为set null等级
  ```

  

#### 创建

- 约束关系是针对双方的

  - 添加了外键约束后，主表的修改和删除数据受约束 
  - 添加了外键约束后，从表的添加和修改数据受约束 
  - 在从表上建立外键，要求主表必须存在
  - 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除

- 建表时

- ```mysql
  create table 主表名称(
  	字段1  数据类型 primary key,    
    字段2  数据类型
  );
  create table 从表名称(
  	字段1  数据类型 primary key,
    字段2  数据类型,
     [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段) );
  #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样 #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样
  -- FOREIGN KEY: 在表级指定子表中的列 
  -- REFERENCES: 标示在父表中的列
  举例
  create table dept( #主表
  	did int primary key,       #部门编号
    dname varchar(50) );       #部门名称
  create table emp(#从表
    eid int primary key,  #员工编号    
    ename varchar(5),     #员工姓名
    deptid int,           #员工所在的部门
    foreign key (deptid) references dept(did)   #在从表中指定外键约束    
    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号 );
  说明：
  （1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。
  （2）删除表时，先删除从表emp，再删除主表dept
  ```

- 建表后

  - ```mysql
    ALTER TABLE 从表名    ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用 字段) [on update xx][on delete xx];
    举例
    ALTER TABLE emp1
    ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);
    ```

#### 删除

- ```mysql
  (1)第一步先查看约束名和删除外键约束
  	SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个 表的约束名
  	ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名; 
  （2）第二步查看索引名和删除索引。（注意，只能手动删除）
  	SHOW INDEX FROM 表名称; #查看某个表的索引名 
  	ALTER TABLE 从表名 DROP INDEX 索引名;
  	
  ```

  

#### 开发场景

- 问题1如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否 一定要建外键约束？
  - 答：不是的
- 问题2：建和不建外键约束有什么区别？
  - 答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限 制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。
  - 不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的  引用完整 性  ，只能依  靠程序员的自觉  ，或者是  在Java程序中进行限定  。例如：在员工表中，可以添加一个员工的 信息，它的部门指定为一个完全不存在的部门。
- 问题3：那么建和不建外键约束和查询有没有关系？
  - 答：没有
- 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允 许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。



### 检查（check）约束

- 检查某个字段的值是否符号xx要求，一般指的是值的范围
- 关键字：CHECK
- 注意：MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告
  但是 MySQL 8.0中可以使用check约束了 。

#### 添加

```
create table employee( 
	eid int primary key,
  ename varchar(5),
  gender char check ('男' or '女') );
insert into employee values(1,'张三','妖');  
```

### 默认（DEFAULT）约束

- 给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默 认值。
- 关键字：DEFAULT

#### 添加

##### 建表时

- ```mysql
  create table 表名称(
  	字段名 数据类型 primary key,
    字段名 数据类型 unique key not null,     
    字段名 数据类型 unique key,
    字段名 数据类型 not null default 默认值, );
  #说明：默认值约束一般不在唯一键和主键列上加
  举例
  create table employee( 
    eid int primary key,
    ename varchar(20) not null,    
    gender char default '男',
    tel char(11) not null default '' #默认是空字符串 );
  ```

##### 建表后

- ```mysql
  alter table 表名称 modify 字段名 数据类型 default 默认值;
  #如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被 删除了
  #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默 认值约束，否则就删除了
  alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
  ```

#### 删除

```mysql
alter table 表名称 modify 字段名 数据类型 default 默认值;#删除默认值约束，也不保留非空约束 
alter table 表名称 modify 字段名 数据类型 default 默认值 not null;; #删除默认值约束，保留非空约束
```

# 视图

- 视图是一种  虚拟表  ，本身是  不具有数据  的，占用很少的内存空间，它是 SQL 中的一个重要概念。 
- 视图建立在已有表的基础上 , 视图赖以建立的这些表称为 基表 。
- 视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和 修改操作时，数据表中的数据会相应地发生变化，反之亦然。
- 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为 存储起来的   SELECT  语句
  - 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。
- 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视 图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我 们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。

## 作用

### 优点

- 操作简单
  将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间 的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简 化了开发人员对数据库的操作。

- 减少数据冗余
  视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语 句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。

- 数据安全
  MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用 户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之 间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上， 用户不需要查询数据表，可以直接 通过视图获取数据表中的信息 。这在一定程度上保障了数据表中数据的安全性。

  - 一方面可以帮我们使用表的一部分而不是所有的表

  - 另一方面也可以针对不同的用户制定不同的查询视图。
    - 针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的 价格，则不会提供给他。
    - 人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他 人的查询视图中则不提供这个字段。

- 适应灵活多变的需求  当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较 大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。

- 能够分解复杂的查询逻辑  数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图 获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。

### 不足

- 如果我们在实际数据表的基础上创建了视图，那么， 如果实际数据表的结构变更了，我们就需要及时对 相关的视图进行相应的维护 。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复 杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包 含复杂的逻辑，这些都会增加维护的成本。
- 实际项目中，如果视图过多，会导致数据库维护成本的问题。所以，在创建视图的时候，要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视 图，使系统整体达到最优。

## 创建

### 单表

- ```mysql
  #在  CREATE VIEW 语句中嵌入子查询
  CREATE [OR REPLACE]
  [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW 视图名称    [(字段列表)]
  AS 查询语句
  [WITH [CASCADED|LOCAL] CHECK OPTION]
  或
  CREATE VIEW 视图名称 AS 查询语句
  举例
  CREATE VIEW empvu80 AS
  SELECT employee_id, last_name, salary 
  FROM    employees
  WHERE   department_id = 80;
  #说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形 成一张虚拟表。
  #说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字 段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。
  ```

### 多表联合视图

- ```mysql
  CREATE VIEW empview AS
  SELECT （多表查询子句）
  举例
  CREATE VIEW dept_sum_vu
  (name, minsal, maxsal, avgsal)
  AS
  SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary) FROM employees e, departments d
  WHERE e.department_id = d.department_id GROUP BY d.department_name;
  ```

### 利用视图对数据进行格式化

- ```mysql
  #我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作
  CREATE VIEW emp_depart AS
  SELECT CONCAT(last_name,'(',department_name,')') AS emp_dept FROM employees e JOIN departments d
  WHERE e.department_id = d.department_id
  ```

### 基于视图创建视图

- ```mysql
  #当我们创建好一张视图之后，还可以在它的基础上继续创建视图。
  举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。
  CREATE VIEW emp_dept_ysalary AS
  SELECT emp_dept.ename,dname,year_salary 
  FROM emp_dept INNER JOIN emp_year_salary ON emp_dept.ename = emp_year_salary.ename;
  ```



## 查询

- ```mysql
  #语法1：查看数据库的表对象、视图对象
  SHOW TABLES;
  
  #语法2：查看视图的结构
  DESC / DESCRIBE 视图名称;
  
  #语法3：查看视图的属性信息
  # 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等） 
  SHOW TABLE STATUS LIKE '视图名称'\G
  #执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。
  
  #语法4：查看视图的详细定义信息
  SHOW CREATE VIEW 视图名称;
  
  #语法5 查询view内容
  select * from view名;#类似于查询表
  ```

## 更新视图

- MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的 数据发生变化时，数据表中的数据也会发生变化，反之亦然。

## 不可更新的视图

- 要使视图可更新，视图中的行和底层基本表中的行之间必须存在  一对一  的关系。
- 就算可以更新视图数据，但总的来说，视图作为  虚拟表  ，主要用于  方便查询  ，不建议更新视图的 数据。 对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。
- 另外当视图定义出现如 下情况时，视图不支持更新操作：
  - 在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作； 
  - 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 
  - 在定义视图的SELECT语句中使用了  JOIN联合查询  ，视图将不支持INSERT和DELETE操作； 
  - 在定义视图的SELECT语句后的字段列表中使用了  数学表达式  或  子查询  ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值；
  - 在定义视图的SELECT语句后的字段列表中使用  DISTINCT 、  聚合函数  、  GROUP BY 、  HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；
  - 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE；
  - 视图定义基于一个  不可更新视图  ； 
  - 常量视图。

## 修改视图

- ```mysql
  #方式1：使用CREATE OR REPLACE VIEW 子句 修改视图
  CREATE OR REPLACE VIEW empvu80
  (id_number, name, sal, department_id)
  AS
  SELECT employee_id, first_name || ' ' || last_name, salary, department_id FROM employees
  WHERE department_id = 80;
  #说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。
  
  #方式2：ALTER VIEW
  ALTER VIEW 视图名称 AS
  查询语句
  ```

## 删除视图

- 删除视图只是删除视图的定义，并不会删除基表的数据。

- ```mysql
  DROP VIEW IF EXISTS 视图名称;
  DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;
  举例
  DROP VIEW empvu80;
  #说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这 样的视图c需要手动删除或修改，否则影响使用。
  ```

  

# 存储过程与存储函数

- MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。
- 存储过程的英文是    Stored Procedure 。它的思想很简单，就是一组经过  预先编译  的  SQL 语句 的封装。
  - 执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用 存储过程的命令，服务器端就可以把预先存储好的这一系列  SQL 语句全部执行。
  - 优点
    - 简化操作，提高了sql语句的重用性，减少了开发程序员的压力 
    - 减少操作过程中的失误，提高效率
    - 减少网络传输量（客户端不需要把所有的  SQL 语句通过网络发给服务器）
    - 减少了  SQL 语句暴露在 网上的风险，也提高了数据查询的安全性
- 视图、函数的对比
- 它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ， 通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集 合的操作方式，能够实现一些更复杂的数据处理。
- 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于 函数，存储过程是  没有返回值的。
- 优点
  - 存储过程可以一次编译多次使用。 存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了  SQL 的执行效率。
  - 可以减少开发工作量。 将代码  封装  成模块，实际上是编程的核心思想之一，这样可以把复杂的问题 拆解成不同的模块，然后模块之间可以  重复使用  ，在减少开发工作量的同时，还能保证代码的结构清 晰。
  - 存储过程的安全性强。 我们在设定存储过程的时候可以  设置对用户的使用权限  ，这样就和视图一样具 有较强的安全性。
  - 可以减少网络传输量。 因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减 少了网络传输量。
  - 良好的封装性。 在进行相对复杂的数据库操作时，原本需要使用一条一条的  SQL 语句，可能要连接 多次数据库才能完成的操作，现在变成了一次存储过程，只需要  连接一次即可  。

- 缺点
  - 可移植性差。 存储过程不能跨数据库移植，比如在  MySQL、Oracle 和  SQL Server 里编写的存储过 程，在换成其他数据库时都需要重新编写。
  - 调试困难。 只有少数  DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容 易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。
  - 存储过程的版本管理很困难。 比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发 软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。
  - 它不适合高并发的场景。 高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方 式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，  增加数据库的压力  ，显然就 不适用了。

- 存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说， 不论怎样，掌握存储过程都是必备的技能之一。

## 存储过程参数分类

- 存储过程的参数类型可以是IN、OUT和INOUT。

- IN、OUT、INOUT 都可以在一个存储过程中带多个。

- | 类型             | 说明          |
  | ---------------- | ------------- |
  | 没有参数         | 无参数无返回  |
  | 仅仅带 IN 类型   | 有参数无返回  |
  | 仅仅带 OUT 类型  | 无参数有返 回 |
  | 既带 IN 又带 OUT | 有参数有返回  |
  | 带 INOUT         | 有参数有返回  |

## 创建存储过程

- ```mysql
  CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名    参数类型,...) 
  [characteristics ...]
  BEGIN
  存储过程体
  END
  举例
  CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))
  BEGIN
  	SELECT ename INTO empname FROM emps
  	WHERE eid = (SELECT MID FROM emps WHERE ename=empname); 
  END;
  ```

  

- | 符号            | 说明                                                         |
  | --------------- | ------------------------------------------------------------ |
  | IN              | 当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，  默认就是     IN ，表示输入参数 |
  | OUT             | 当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。 |
  | INOUT           | 当前参数既可以为输入参数，也可以为输出参数。                 |
  | characteristics | 表示创建存储过程时指定的对存储过程的约束条件                 |

  - 形参类型可以是  MySQL数据库中的任意类型。

  - 存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略  BEGIN 和  END 编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的  SQL 语句。

    - BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。

    2. DECLARE：DECLARE 用来声明变量，使用的位置在于    BEGIN…END 语句中间，而且需要在其他语句使用之前进 行变量的声明。
    3. SET：赋值语句，用于对变量进行赋值。
    4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。

### characteristics

- ```
  LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL| NO SQL| READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER } 
  | COMMENT 'string'
  ```

- | 符号              | 说明                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | LANGUAGE SQL      | 说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。 |
  |                   |                                                              |
  | DETERMINISTIC     | 指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。 |
  | NOT DETERMINISTIC | 表示结果是不确定 的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。 |
  |                   |                                                              |
  | CONTAINS SQL      | 表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句 |
  | NO SQL            | 表示当前存储过程的子程序中不包含任何SQL语句                  |
  | READS SQL DATA    | 表示当前存储过程的子程序中包含读数据的SQL语句                |
  | MODIFIES SQL DATA | 表示当前存储过程的子程序中包含写数据的SQL语句。 默认情况下，系统会指定为CONTAINS SQL。 |
  | SQL SECURITY      | 执行当前存储过程的权限，即指明哪些用户能够执 行当前存储过程。 |
  |                   |                                                              |
  | DEFINER           | 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程   |
  | INVOKER           | 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 如果没有设置相关的值，则MySQL默认指定值为DEFINER。 |
  | COMMENT 'string'  | 注释信息，可以用来描述存储过程。                             |

### 需要设置新的结束标记

- 因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用 DELIMITER改变存储过程的结束符。

  - 比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定 义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。

- 当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。

- 如果你用的是  Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置  DELIMITER 为其他符号， 我们不需要再进行 DELIMITER 的操作。

- ```mysql
  DELIMITER 新的结束标记
  DELIMITER;
  举例
  DELIMITER //
  CREATE PROCEDURE avg_employee_salary () 
  BEGIN
  	SELECT AVG(salary) AS avg_salary FROM emps; 
  END //
  DELIMITER ;
  ```

## 使用存储过程

- 存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行 其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。

- ```mysql
  CALL 存储过程名(实参列表)
  #1、调用in模式的参数：
  CALL sp1('值');
  
  
  #2、调用out模式的参数：
  SET @name; 
  CALL sp1(@name); 
  SELECT @name;
  
  #3、调用inout模式的参数
  SET @name=值; 
  CALL sp1(@name); 
  SELECT @name;
  
  举例
  DELIMITER //
  CREATE PROCEDURE CountProc(IN sid INT,OUT num INT) 
  BEGIN
  SELECT COUNT(*) INTO num FROM fruits WHERE s_id = sid;
  END // 
  DELIMITER ;
  SET @num;
  CALL CountProc (101, @num);
  ```

### 如何调试

- 在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因 此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。
- 调试 成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。
- 这样 逐步推进 ，就可 以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独 调试。

## 创建存储函数

- 前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理 效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。

- 语法分析：学过的函数：LENGTH、SUBSTR、CONCAT等

- ```mysql
  CREATE FUNCTION 函数名(参数名    参数类型,...) 
  RETURNS 返回值类型
  [characteristics ...]
  BEGIN
  	函数体      #函数体中肯定有RETURN 语句 
  END
  
  举例
  创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型 为字符串型。
  DELIMITER //
  CREATE FUNCTION email_by_id(emp_id INT) 
  RETURNS VARCHAR(25)
  DETERMINISTIC 
  CONTAINS SQL 
  BEGIN
  	RETURN (SELECT email FROM employees WHERE employee_id = emp_id); 
  END //
  DELIMITER ;
  SET @emp_id = 102; 
  SELECT email_by_id(102);
  ```

  - 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参 数。
  - RETURNS type 语句表示函数返回数据的类型；
  - RETURNS子句只能对FUNCTION做指定，对函数而言这是  强制  的。它用来指定函数的返回类型，而且函 数体必须包含一个  RETURN value 语句。
  - characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同。
  - 函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。

##  使用存储函数

- 在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存 储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL 的 开发者定义 的。

- ```mysql
  SELECT 函数名(实参列表)
  
  举例
  SET @emp_id = 102; 
  SELECT email_by_id(102);
  ```

##  对比存储函数和存储过程

|          | 关键字    | 调用语法         | 返回值             | 应用场景                          |
| -------- | --------- | ---------------- | ------------------ | --------------------------------- |
| 存储过程 | PROCEDURE | CALL 存储过 程() | 理解为有0个或 多个 | 一般用于更新                      |
| 存储函数 | FUNCTION  | SELECT 函数 ()   | 只能是一个         | 一般用于查询结果为一个值并 返回时 |

- 存储函数可以放在查询语句中使用，存储过程不行 。反之，存储过程的功能更加强大，包括能够 执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。

## 存储过程和函数的查看、修改、删除

- 创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？
- MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查 看，也可直接从系统的information_schema数据库中查询。

### 查看

- ```mysql
  #1. 使用SHOW CREATE语句查看存储过程和函数的创建信息
  SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名
  举例
  SHOW CREATE FUNCTION test_db.CountProc \G
  
  #2. 使用SHOW STATUS语句查看存储过程和函数的状态信息
  SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']
  #这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。
  #[LIKE 'pattern']：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的 所有存储过程或函数的信息。 
  
  #3. 从information_schema.Routines表中查看存储过程和函数的信息
  MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。
  SELECT * FROM information_schema.Routines
  WHERE ROUTINE_NAME='存储过程或函数的名' [AND ROUTINE_TYPE = {'PROCEDURE|FUNCTION'}];
  #说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来 指明查询的是存储过程还是函数。
  ```

### 修改

- 修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现

- ```mysql
  ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名    [characteristic ...]
  #其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有 不同。
  { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } 
  | SQL SECURITY { DEFINER | INVOKER }
  | COMMENT 'string'
  #修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。
  
  举例
  修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行
  ALTER　PROCEDURE　CountProc 
  MODIFIES SQL DATA
  SQL SECURITY INVOKER ;
  ```

### 删除

- 删除存储过程和函数，可以使用DROP语句

- ```mysql
  DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名
  举例
  DROP PROCEDURE CountProc;
  ```

# 变量、流程控制与游标

## 变量

- 在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终 的结果数据。
- 在 MySQL 数据库中，变量分为  系统变量  以及  用户自定义变量  。

### 系统变量

#### 系统变量分类

- 变量由系统定义，不是用户定义，属于  服务器  层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特 征。这些系统变量的值要么是  编译MySQL时参数  的默认值，要么是  配置文件  （例如my.ini等）中的参数 值。大家可以通过网址 `https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html`查看MySQL文档的系统变量。

- 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键 字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。 如果不写，默认 会话级别。 静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系 统变量。

- 每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变 量值的复制。

  - 全局系统变量针对于所有会话（连接）有效，但  不能跨重启

  - 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修 改，不会影响其他会话同一个会话系统变量的值。

  - 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。

- 在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。

#### 查看

- ```mysql
  #查看所有全局变量
  SHOW GLOBAL VARIABLES; 
  
  #查看所有会话变量
  SHOW SESSION VARIABLES; 或 SHOW VARIABLES;
  
  #查看满足条件的部分系统变量。
  SHOW GLOBAL VARIABLES LIKE '%标识符%'; 
  
  #查看满足条件的部分会话变量
  SHOW SESSION VARIABLES LIKE '%标识符%';
  
  #查看指定系统变量
  作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变 量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。
  #查看指定的系统变量的值 
  SELECT @@global.变量名;
  
  #查看指定的会话变量的值 
  SELECT @@session.变量名; #或者 
  SELECT @@变量名;
  ```

  

#### 修改

- 有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。

  - 方式1：修改MySQL 配置文件  ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务） 
  - 方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值

- ```mysql
  #为某个系统变量赋值 
  #方式1：
  SET @@global.变量名=变量值; 
  
  #方式2：
  SET GLOBAL 变量名=变量值; 
  
  SELECT @@global.autocommit; 
  SET GLOBAL autocommit=0;
  #为某个会话变量赋值
  #方式1：
  SET @@session.变量名=变量值; 
  
  #方式2：
  SET SESSION 变量名=变量值;
  ```

### 用户变量

- 用户变量是用户自己定义的，作为  MySQL 编码规范，MySQL 中的用户变量以  一个“@” 开头。根据作用 范围不同，又分为  会话用户变量  和  局部变量  。
- 会话用户变量：作用域和会话变量一样，只对  当前连接  会话有效。
- 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在  存储过程和函数  中使用。

#### 会话用户变量

- ```mysql
  #变量的定义
  #方式1：“=”或“:=”
  SET @用户变量 = 值;
  SET @用户变量 := 值;
  SET @a = 1;
  #方式2：“:=” 或 INTO关键字
  SELECT @用户变量 := 表达式 [FROM 等子句]; SELECT 表达式 INTO @用户变量 [FROM 等子句];
  SELECT @num := COUNT(*) FROM employees;
  SELECT AVG(salary) INTO @avgsalary FROM employees;
  
  #查看用户变量的值 （查看、比较、运算等）
  SELECT @用户变量
  ```

#### 局部变量

- 定义：可以使用  DECLARE 语句定义一个局部变量 

- 作用域：仅仅在定义它的 BEGIN ... END 中有效 位置：只能放在  BEGIN ... END 中，而且只能放在第一句

- ```mysql
  BEGIN
  
  #声明局部变量
  DECLARE 变量名1 变量数据类型    [DEFAULT 变量默认值]; # 如果没有DEFAULT子句，初始值为NULL
  DECLARE 变量名2,变量名3,... 变量数据类型    [DEFAULT 变量默认值]; 
  
  #为局部变量赋值
  SET 变量名1 = 值;
  SELECT 值 INTO 变量名2 [FROM 子句]; 
  
  #查看局部变量的值
  SELECT 变量1,变量2,变量3; 
  END
  ```

#### 对比会话用户变量与局部变量

|              | 作用域              | 定义位置            | 语法                     |
| ------------ | ------------------- | ------------------- | ------------------------ |
| 会话用户变量 | 当前会话            | 会话的任何地方      | 加@符号，不用指定类型    |
| 局部变量     | 定义它的BEGIN END中 | BEGIN END的第一句话 | 一般不用加@,需要指定类型 |

## 定义条件与处理程序

- 定义条件  是事先定义程序执行过程中可能遇到的问题。
- 处理程序  定义了在遇到问题时应当采取的处理方 式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能 力，避免程序异常停止运行。
  - 说明：定义条件和处理程序在存储过程、存储函数中都是支持的。

### 定义条件

- 定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。

- 它将一个  错误名字  和  指定的 错误条件  关联起来。

- 这个名字可以随后被用在定义处理程序的  DECLARE HANDLER 语句中。

- ```mysql
  DECLARE 错误名称    CONDITION FOR 错误码（或错误条件）
  举例
  #使用MySQL_error_code
  DECLARE Field_Not_Be_NULL CONDITION FOR 1048; 
  
  #使用sqlstate_value
  DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
  ```

  - MySQL_error_code 和  sqlstate_value 都可以表示MySQL的错误。 
  - MySQL_error_code是数值类型错误代码。
  - sqlstate_value是长度为5的字符串类型错误代码。
    - 例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，'HY000'是sqlstate_value。
    - 例如，在ERROR 1142（42000）中，1142是MySQL_error_code，'42000'是sqlstate_value。

### 定义处理程序

- 可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。

- ```mysql
  DECLARE 处理方式    HANDLER FOR 错误类型    处理语句
  #方法1：捕获sqlstate_value
  DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE'; 
  
  #方法2：捕获mysql_error_value
  DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE'; 
  
  #方法3：先定义条件，再调用
  DECLARE no_such_table CONDITION FOR 1146;
  DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE'; 
  
  #方法4：使用SQLWARNING
  DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR'; 
  
  #方法5：使用NOT FOUND
  DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE'; 
  
  #方法6：使用SQLEXCEPTION
  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';
  ```

  - | 处理方式 | 说明                                                        |
    | -------- | ----------------------------------------------------------- |
    | CONTINUE | 表示遇到错误不处理，继续执行。                              |
    | EXIT     | 表示遇到错误马上退出。                                      |
    | UNDO     | 表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。 |

  - | 错误类型                | 说明                                                        |
    | ----------------------- | ----------------------------------------------------------- |
    | SQLSTATE '字符串错误码' | 表示长度为5的sqlstate_value类型的错误代码；                 |
    | MySQL_error_code        | 匹配数值类型错误代码                                        |
    | 错误名称                | 表示DECLARE ... CONDITION定义的错误条件名称。               |
    | SQLWARNING              | 匹配所有以01开头的SQLSTATE错误代码；                        |
    | NOT FOUND               | 匹配所有以02开头的SQLSTATE错误代码；                        |
    | SQLEXCEPTION            | 匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码； |

  - 处理语句 ：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是 像“ SET 变量     = 值  ”这样的简单语句，也可以是使用  BEGIN ... END 编写的复合语句。

## 流程控制

- 解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。流程 就分为三大类：
  - 顺序结构  ：程序从上往下依次执行
  - 分支结构  ：程序按条件进行选择执行，从两条或多条路径中选择一条执行 
  - 循环结构  ：程序满足一定条件下，重复执行一组语句
- 针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。
  - 条件判断语句  ：IF 语句和 CASE 语句 
  - 循环语句  ：LOOP、WHILE 和 REPEAT 语句 
  - 跳转语句  ：ITERATE 和 LEAVE 语句

### 分支结构

#### IF

- ```mysql
  IF 表达式1 THEN 操作1
  [ELSEIF 表达式2 THEN 操作2]…… [ELSE 操作N]
  END IF
  #根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。
  #特点：1、不同的表达式对应不同的操作 2、使用在begin end中
  
  举例
  IF val IS NULL
  THEN SELECT 'val is null'; ELSE SELECT 'val is not null';
  END IF;
  ```

#### CASE

```mysql
#情况一：类似于switch 
CASE 表达式
WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) 
WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）

举例
CASE val
　　　WHEN 1 THEN SELECT 'val is 1'; 　　　
　　　WHEN 2 THEN SELECT 'val is 2'; 　　　
　　　ELSE SELECT 'val is not 1 or 2'; 
 END CASE;
#情况二：类似于多重if
CASE
WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) 
WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）

举例
CASE
WHEN val IS NULL THEN SELECT 'val is null';
WHEN val < 0 THEN SELECT 'val is less than 0';
WHEN val > 0 THEN SELECT 'val is greater than 0'; ELSE SELECT 'val is 0';
END CASE;
```

###  循环结构

#### LOOP

- LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子 句），跳出循环过程。

- ```mysql
  [loop_label:] LOOP 
  	循环执行的语句
  END LOOP [loop_label]
  #其中，loop_label表示LOOP语句的标注名称，该参数可以省略。
  
  举例
  #使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。
  DECLARE id INT DEFAULT 0; add_loop:LOOP
  SET id = id +1;
  IF id >= 10 THEN LEAVE add_loop; END IF;
  END LOOP add_loop;
  ```

#### WHILE

- WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。

- ```mysql
  [while_label:] WHILE 循环条件 DO 
  	循环体
  END WHILE [while_label];
  #while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直 至循环条件为假，退出循环。
  
  举例：
  WHILE语句示例，i值小于10时，将重复执行循环过程
  DELIMITER //
  CREATE PROCEDURE test_while() BEGIN
  DECLARE i INT DEFAULT 0; WHILE i < 10 DO
  SET i = i + 1; END WHILE;
  SELECT i; END //
  DELIMITER ; 
  #调用
  CALL test_while();
  ```

#### REPEAT

- REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循 环，然后在  UNTIL 中进行表达式的判断，如果满足条件就退出，即  END REPEAT；如果条件不满足，则会 就继续执行循环，直到满足退出条件为止。

- ```mysql
  [repeat_label:] REPEAT 　　　　
  	循环体的语句
  UNTIL 结束循环的条件表达式 
  END REPEAT [repeat_label]
  #repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至 expr_condition为真。
  
  举例
  DELIMITER //
  CREATE PROCEDURE test_repeat() 
  BEGIN
  DECLARE i INT DEFAULT 0; REPEAT
  SET i = i + 1; UNTIL i >= 10 END REPEAT;
  SELECT i; END //
  DELIMITER ;
  ```

#### 对比三种循环结构

1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名 称。

 2、 LOOP：一般用于实现简单的"死"循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件 至少执行一次

### 跳转语句

#### LEAVE语句

- EAVE语句：可以用在循环语句内，或者以  BEGIN 和  END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把  LEAVE 理解为 break。

- ```mysql
  LEAVE 标记名
  #其中，label参数表示循环的标志。LEAVE和BEGIN ... END或循环一起被使用。
  ```

#### ITERATE语句

- ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序 转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意 思为“再次循环”。

- ```mysql
  ITERATE label
  
  举例： 
  定义局部变量num，初始值为0。循环结构中执行num + 1操作。
  如果num < 10，则继续执行循环； 如果num > 15，则退出循环结构；
  DELIMITER //
  CREATE PROCEDURE test_iterate() 
  BEGIN
  DECLARE num INT DEFAULT 0; 
  my_loop:LOOP
  SET num = num + 1; 
  IF num < 10
  	THEN ITERATE my_loop; 
  ELSEIF num > 15
  	THEN LEAVE my_loop; END IF;
  SELECT '12345'; 
  END LOOP my_loop;
  END // 
  DELIMITER ;
  ```

## 游标

- 虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一 条记录 ，并对记录的数据进行处理。
- 这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。 游标让 SQL 这种面向集合的语言有了面向过 程开发的能力。
- 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标  充当了 指针的作用  ，我们可以通过操作游标来对数据行进行操作。
- MySQL中游标可以在存储过程和函数中使用。
- 游标是 MySQL 的一个重要的功能，为  逐条读取  结果集中的数据，提供了完美的解决方案。跟在应用层 面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。
- 游标同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。
- 建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。

#### 使用游标步骤

- 游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。 如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。

- ```mysql
  #第一步，声明游标
  使用DECLARE关键字来声明游标,这个语法适用于  MySQL，SQL Server，DB2 和 MariaDB
  DECLARE cursor_name CURSOR FOR select_statement;
  
  如果是用 Oracle 或者  PostgreSQL，需要写成
  DECLARE cursor_name CURSOR IS select_statement;
  
  #要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里  select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。
  DECLARE cur_emp CURSOR FOR
  SELECT employee_id,salary FROM employees;
  
  #第二步，打开游标
  OPEN cursor_name
  #当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候  SELECT 语句的查询结 果集就会送到游标工作区，为后面游标的  逐条读取  结果集中的记录做准备。
  
  #第三步，使用游标（从游标中取得数据）
  FETCH cursor_name INTO var_name [, var_name] ...
  #这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游 标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。
  #注意：var_name必须在声明游标之前就定义好。
  #注意： 游标的查询结果集中的字段数，必须跟  INTO 后面的变量数一致 ，否则，在存储过程执行的时 候，MySQL 会提示错误。
  
  #第四步，关闭游标
  CLOSE cursor_name
  #有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会 占用系统资源 ，如果不及时关闭， 游标会一直保持到存储过程结束 ，影响系统运行的效率。而关闭游标 的操作，会释放游标占用的系统资源。
  #关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。
  
  举例
  创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明 OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。
  DELIMITER //
  CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)
  BEGIN
  DECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资
  DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值
  DECLARE emp_count INT DEFAULT 0; #记录循环个数 #定义游标
  DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC; #打开游标
  OPEN emp_cursor; REPEAT
  #使用游标（从游标中获取数据）
  FETCH emp_cursor INTO cursor_salary;
  SET sum_salary = sum_salary + cursor_salary; SET emp_count = emp_count + 1;
  UNTIL sum_salary >= limit_total_salary 
  END REPEAT;
  SET total_count = emp_count; #关闭游标
  CLOSE emp_cursor; 
  END //
  DELIMITER ;
  ```

  

## 全局变量的持久化

- MySQL 8.0的新特性—全局变量的持久化

- 在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可 以通过设置系统变量max_execution_time来实现

  - ```mysql
    SET GLOBAL MAX_EXECUTION_TIME=2000;
    ```

  - 使用SET GLOBAL语句设置的变量值只会  临时生效  。  数据库重启  后，服务器又会从MySQL配置文件中读取 变量的默认值。 

- MySQL 8.0版本新增了  SET PERSIST 命令。例如，设置服务器的最大连接数为1000

  - ```mysql
    SET PERSIST global max_connections = 1000;
    ```

  - MySQL会将该命令的配置保存到数据目录下的  mysqld-auto.cnf 文件中，下次启动时会读取该文件，用 其中的配置来覆盖默认的配置文件。

# 触发器

## 背景

- 在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分 
  别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时 
  在库存表中添加一条库存记录。
- 这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操 
  作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手 
  动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。
- 这个时候，可以使用触发器。 你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数 
  据的插入操作。 这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。

## 简介

- MySQL从  5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。
- 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指 用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会自动激发触发器执行相应的操作。
- 当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。
- 注意：如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此 时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE和DELETE语句定义的触发器并不会被激活。
  - 例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定 义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee） 有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器 t1。

### 优点

1. 触发器可以确保数据的完整性 。
   - 假设我们用  进货单头表  （demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编 号、仓库编号、总计进货数量、总计进货金额和验收日期。
   - 用  进货单明细表  （demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数 量、进货价格和进货金额。
   - 每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时 
     候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金 
     额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。
   - 为了解决这个问题，我们就可以使用触发器， 规定每当进货单明细表有数据插入、修改和删除的操作 
     时，自动触发  2 步操作：
     1. 重新计算进货单明细表中的数量合计和金额合计；
     2. 用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。
   - 这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与 
     合计金额的值相同，数据就是一致的，不会互相矛盾。
2. 触发器可以帮助我们记录操作日志。
   - 利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很 
     好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。
3. 触发器还可以用在操作数据前，对数据进行合法性检查。
   - 比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的 
     时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏…… 
     这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止 
     错误数据进入系统。

### 缺点

1. 触发器最大的一个问题就是可读性差。

   - 因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能  不受应用层的控制  。这对系统 
     维护是非常有挑战的。

   - 比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失 
     败。

   - ```mysql
     mysql> update demo.membermaster set memberdeposit=20 where memberid = 2; 
     ERROR 1054 (42S22): Unknown column 'aa' in 'field list'
     ```

   - 结果显示，系统提示错误，字段“aa”不存在。

   - 这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器， 
     很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表 
     添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。

2. 相关数据的变更，可能会导致触发器出错。

   - 特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触 
     发器本身的隐蔽性，影响到应用中错误原因排查的效率。

## 创建

- ```mysql
  CREATE TRIGGER 触发器名称
  {BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名 
  FOR EACH ROW
  触发器执行的语句块;
  #触发器执行的语句块  ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。
  
  举例
  定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查 
  将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为'HY000'的错 
  误，从而使得添加失败。
  DELIMITER //
  CREATE TRIGGER salary_check_trigger 
  BEFORE INSERT ON employees FOR EACH ROW 
  BEGIN
  	DECLARE mgrsalary DOUBLE;
  	#上NEW关键字代表INSERT添加语句的新记录。
  	SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id; 
  	IF NEW.salary > mgrsalary THEN
  		SIGNAL SQLSTATE 'HY000' SET MESSAGE_TEXT = '薪资高于领导薪资错误'; 
  	END IF;
  END // 
  DELIMITER ;
  ```

## 查看和删除

- 查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。

  - ```mysql
    #方式1：查看当前数据库的所有触发器的定义
    SHOW TRIGGERS\G
    
    #方式2：查看当前数据库中某个触发器的定义
    SHOW CREATE TRIGGER 触发器名
    
    #方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。
    SELECT * FROM information_schema.TRIGGERS;
    ```

- 触发器也是数据库对象，删除触发器也用DROP语句

  - ```mysql
    DROP TRIGGER  IF EXISTS 触发器名称;
    ```

# MySQL8其它新特性

- MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上 做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。

##  新增特性

- 更简便的NoSQL支持 NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统 的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。 MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。

- 更好的索引：  在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了  隐藏索引  和  降序索 引  。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引 可以提高查询的性能。

- 更完善的JSON支持： MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加 了聚合函数 JSON_ARRAYAGG() 和 JSON_OBJECTAGG() ，将参数聚合为JSON数组或对象，新增了行内 操作符 ->>，是列路径运算符 ->的增强，对JSON排序做了提升，并优化了JSON的更新操作。

- 安全和账户管理 ： MySQL 8中新增了 caching_sha2_password 授权插件、角色、密码历史记录和FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。

- InnoDB的变化 ：    InnoDB是MySQL默认的存储引擎  ，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面 做了大量的 改进和优化 ，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的 
  支持。

- 数据字典 ： 在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。

- 原子数据定义语句 ： MySQL 8开始支持原子数据定义语句（Automic DDL），即  原子DDL 。目前，只有 InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎 操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。 
  使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操 作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加  IF EXISTS 或  IF NOT EXISTS 语句来避免发生错误。

- 资源管理：  MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便 线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够 根据不同的工作负载适当地更改这些属性。 目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表 
  示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有 对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户 
  组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的 属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配 置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS 
  系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统 中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。

- 字符集支持：  MySQL 8中默认的字符集由  latin1 更改为  utf8mb4 ，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。

- 优化器增强 MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。

- 公用表表达式 ： 公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前  使用WITH语句对临时结果集  进行命名。

  - ```mysql
    WITH cte_name (col_name1,col_name2 ...) AS (Subquery) 
    SELECT * FROM cte_name;
    
    #Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。
    ```

- 窗口函数：MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分  聚合函数  在MySQL 8中也可以 作为窗口函数来使用。

- 正则表达式支持：  MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作， 这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、 EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和 
  regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。
- 内部临时表   ：  TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎  。TempTable存储 引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部 临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。 temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。
- 日志记录：在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量 log_error_services来配置，能够实现日志事件的过滤和写入
- 备份锁： 新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。
- 增强的MySQL复制 MySQL 8复制支持对 JSON文档 进行部分更新的 二进制日志记录 ，该记录 使用紧凑 的二进制格式 ，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记 录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。

## 移除的旧特性

- 在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。
- 查询缓存     查询缓存已被移除  ，删除的项有：  
  - 语句： FLUSH QUERY CACHE和RESET QUERY CACHE。  
  - 系统变量： query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。  
  - 状态变量： Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、 
    Qcache_queries_in_cache、Qcache_total_blocks。  
  - 线程状态： checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。
- 加密相关  删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项， HAVE_CRYPT CMake选项。 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使 
  用AES_ENCRYPT()和AES_DECRYPT()替代。
- 空间函数相关  在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被 移除，只保留了对应的ST_和MBR函数。
- \N和NULL 在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化 不会影响使用LOAD DATA INFILE或者SELECT...INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL 仍等同于\N。
- mysql_install_db 在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着-- initialize或者--initialize-insecure选项的mysqld来代替实现。另外，--bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。
- 通用分区处理程序 通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存 储引擎需要自有的分区处理程序。 提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在 MySQL 8中只支持InnoDB。
- 系统和状态变量信息  在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。 GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系 统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、
  Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除 的内容都可使用性能模式中对应的内容进行替代。
- mysql_plugin工具 mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用--plugin-load或- -plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。

## 窗口函数

- MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组 操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。
- 窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用
- 窗口函数可以分为  静态窗口函数  和  动态窗口函数  。
  - 静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同； 
  - 动态窗口函数的窗口大小会随着记录的不同而变化。

| 函数分类 | 函数               | 函数说明                                        |
| -------- | ------------------ | ----------------------------------------------- |
| 序号函数 | ROW NUMBER()       | 顺序排序                                        |
|          | RANK(）            | 并列排序，会跳过重复的序号，比如序号为1、1、3   |
|          | DENSE_ RANK（）    | 并列排序，不会跳过重复的序号，比如序号为1、1、2 |
| 分布函数 | PERCENT RANK(）    | 等级值百分比                                    |
|          | CUME DIST()        | 累积分布值                                      |
| 前后函数 | LAG(expr, n)       | 返回当前行的前n行的expr的值                     |
|          | LEAD(expr, n)      | 返回当前行的后n行的expr的值                     |
| 首尾函数 | FIRST_VALUE(expr)  | 返回第一个expr的值                              |
|          | LAST_VALUE(expr)   | 返回最后一个expr的值                            |
| 其他函数 | NTH_VALUE(expr, n) | 返回第n个expr的值                               |
|          | NTILE(n)           | 将分区中的有序数据分为n个桶，记录桶编号         |

- ```mysql
  语法格式
  函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）
  或
  函数 OVER 窗口名 … WINDOW 窗口名 AS（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）
  ```

  - | 关键字           | 说明                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | OVER             | 关键字指定函数窗口的范围。<br/>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所 有满足WHERE条件的记录进行计算。<br/>如果OVER关键字后面的括号不为空，则可以使用后面的语句设置窗口。 |
    | 窗口名           | 为窗口设置一个别名，用来标识窗口。                           |
    | PARTITION BY子句 | 指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。 |
    | ORDER BY子句     | 指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据 记录的顺序进行编号。 |
    | FRAME子句        | 为分区中的某个子集定义规则，可以用来作为滑动窗口使用。       |

### 序号函数

#### ROW_NUMBER()函数

- ROW_NUMBER()函数能够对数据中的序号进行顺序显示。

- ```mysql
  查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。
  SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,
  id, category_id, category, NAME, price, stock 
  FROM goods;
  ```

#### RANK()函数

- 使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。

  - 在名称为“女装/女士精品”的商品类别中，有两款商品的价格为89.90元，分别是卫衣和牛仔裤。两款商品 
    的序号都应该为2，而不是一个为2，另一个为3。此时，可以使用RANK()函数和DENSE_RANK()函数解 
    决。

- ```mysql
  SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num, 
  id, category_id, category, NAME, price, stock
  FROM goods;
  ```

#### DENSE_RANK()函数

- DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。

### 分布函数

#### PERCENT_RANK()函数

- PERCENT_RANK()函数是等级值百分比函数。按照`(rank - 1) / (rows - 1)`进行计算。

  - rank的值为使用RANK()函数产生的序号
  - rows的值为当前窗口的总记录数。

- ```mysql
  举例
  计算  goods 数据表中名称为“女装/女士精品”的类别下的商品的PERCENT_RANK值。
  #写法一：
  SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r, 
  PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr, 
  id, category_id, category, NAME, price, stock
  FROM goods
  WHERE category_id = 1; 
  #写法二：
  SELECT RANK() OVER w AS r, PERCENT_RANK() OVER w AS pr,id, category_id, category, NAME, price, stock 
  FROM goods
  WHERE category_id = 1 
  WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);
  ```

#### CUME_DIST()函数

- CUME_DIST()函数主要用于查询小于或等于某个值的比例。

### 前后函数

#### LAG(expr,n)函数

- LAG(expr,n)函数返回当前行的前n行的expr的值。

- ```mysql
  查询goods数据表中前一个商品价格与当前商品价格的差值。
  SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price 
  FROM (
    SELECT id, category, NAME, price,LAG(price,1) OVER w AS pre_price 
    FROM goods
    WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;
    
  ```

#### LEAD(expr,n)函数

- LEAD(expr,n)函数返回当前行的后n行的expr的值。

- ```mysql
  举例：查询goods数据表中后一个商品价格与当前商品价格的差值。
  SELECT id, category, NAME, behind_price, price,behind_price - price AS diff_price
  FROM(
  SELECT id, category, NAME, price,LEAD(price, 1) OVER w AS behind_price 
  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;
  ```

### 首尾函数

#### FIRST_VALUE(expr)函数

- FIRST_VALUE(expr)函数返回第一个expr的值。

- ```mysql
  按照价格排序，查询第1个商品的价格信息。
  SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS first_price
  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);
  ```

#### LAST_VALUE(expr)函数

- LAST_VALUE(expr)函数返回最后一个expr的值。

- ```mysql
  按照价格排序，查询最后一个商品的价格信息。
  SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price 
  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);
  ```

###  其他函数

#### NTH_VALUE(expr,n)函数

- NTH_VALUE(expr,n)函数返回第n个expr的值。

- ```mysql
  查询goods数据表中排名第2和第3的价格信息。
  SELECT id, category, NAME, price,NTH_VALUE(price,2) OVER w AS second_price, 
  NTH_VALUE(price,3) OVER w AS third_price
  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);
  ```

#### NTILE(n)函数

- NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号

- ```mysql
  将goods表中的商品按照价格分为3组。
  SELECT NTILE(3) OVER w AS nt,id, category, NAME, price
  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);
  ```

## 公用表表达式

- 公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结 果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的， CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。 
- 依据语法结构和执行方式的不同，公用表表达式分为  普通公用表表达式  和  递归公用表表达式 2 种。
  - 公用表表达式的作用是可以替代子查询，而且可以被多次引用。
  - 递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。

### 普通公用表表达式

- 普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普 通公用表表达式所引用。

- ```mysql
  WITH CTE名称 
  AS （子查询）
  SELECT|DELETE|UPDATE 语句;
  
  举例：查询员工所在的部门的详细信息。
  
  子查询的方法
  SELECT * FROM departments 
  WHERE department_id IN (
                    SELECT DISTINCT department_id 
                    FROM employees
                   );
                   
  普通公用表达式                 
  WITH emp_dept_id
  AS (SELECT DISTINCT department_id FROM employees) 
  SELECT *
  FROM departments d JOIN emp_dept_id e 
  ON d.department_id = e.department_id;
  
  ```

  - 公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询 之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有 一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询 
    则不能。

果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的， 

- CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。

### 递归公用表表达式

- 递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是 可以调用自己 。

- 递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。 这里的 种子查询，意思就是获得递归的初始值 。这个查询只会运行一次，以创建初始数据集，之后递归 查询会一直执行，直到没有任何新的查询数据产生，递归返回。

- ```mysql
  WITH RECURSIVE
  CTE名称    AS （子查询） 
  SELECT|DELETE|UPDATE 语句;
  
  举例
  列出所有具有下下属身份的人员信息。
  WITH RECURSIVE cte 
  AS
  (
  SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100 
  -- 种子查询，找到第一代领导
  UNION ALL
  SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte 
  ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人 
  )
  SELECT employee_id,last_name FROM cte WHERE n >= 3;
  ```

  

- 特点，就是 可以调用自己 。

















